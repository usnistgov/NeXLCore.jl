<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API: Structures and Methods · NeXLCore</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link rel="stylesheet" href="https://pages.nist.gov/nist-header-footer/css/nist-combined.css">
<script src="https://pages.nist.gov/nist-header-footer/js/jquery-1.9.0.min.js" type="text/javascript" defer="defer"></script>
<script src="https://pages.nist.gov/nist-header-footer/js/nist-header-footer.js" type="text/javascript" defer="defer"></script>
</head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../gettingstarted/"><img src="../assets/logo.png" alt="NeXLCore logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../gettingstarted/">NeXLCore</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../gettingstarted/">Getting Started</a></li><li><a class="tocitem" href="../material/">Materials</a></li><li><a class="tocitem" href="../bremsstrahlung/">Bremsstrahlung</a></li><li><a class="tocitem" href="../Au60Ag40unc/">Mass Fraction Uncertainty</a></li><li><a class="tocitem" href="../eta/">Backscatter</a></li><li><a class="tocitem" href="../fluoryield/">Fluorescence Yield</a></li><li><a class="tocitem" href="../OByStoic/">O by Stoichiometry</a></li><li><a class="tocitem" href="../meanionizationpotential/">Mean Ionization Potential</a></li><li class="is-active"><a class="tocitem" href>API: Structures and Methods</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API: Structures and Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API: Structures and Methods</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/usnistgov/NeXLCore.jl/blob/master/docs/src/methods.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="NeXLCore-Types,-Functions-and-Methods"><a class="docs-heading-anchor" href="#NeXLCore-Types,-Functions-and-Methods">NeXLCore Types, Functions and Methods</a><a id="NeXLCore-Types,-Functions-and-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#NeXLCore-Types,-Functions-and-Methods" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.GrayScale" href="#NeXLCore.GrayScale"><code>NeXLCore.GrayScale</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>An RGB gray-scale palette with entry 256 being yellow.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Log3BandBright" href="#NeXLCore.Log3BandBright"><code>NeXLCore.Log3BandBright</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Dave Bright&#39;s palette suited to use with log base-10 transformed data on the range [0.0, 1.0]. The 256ᵗʰ entry is yellow for an error condition.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Log3BandColorblind" href="#NeXLCore.Log3BandColorblind"><code>NeXLCore.Log3BandColorblind</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>A colorblind friendly palette suited to use with log base-10 transformed data on the range [0.0, 1.0].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.allsubshells" href="#NeXLCore.allsubshells"><code>NeXLCore.allsubshells</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">allsubshells</code></pre><p>A tuple containing all K, L, M, N and O sub-shells</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.alltransitions" href="#NeXLCore.alltransitions"><code>NeXLCore.alltransitions</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">alltransitions</code></pre><p>A complete list of all the transitions present in one or more elements.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.atomic_weight" href="#NeXLCore.atomic_weight"><code>NeXLCore.atomic_weight</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">atomic_weight[elm::Element]::Union{NumberInterval, UncertainValue}</code></pre><p>Atomic weights from the 2020 tabulation at https://ciaaw.org/atomic-weights.htm.  Not all elements are represented because not all  elements have a nominal isotopic distribution.  Some, like Tc, don&#39;t exist in nature.  Others, like Pm, are instable.  Most atomic weights are given as <code>UncertainValue</code> instances while a few are <code>NumberInterval</code> instances.  For example, the atomic weight of Pb is highly variable and is thus given as a range.  (See the website for more details.)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.a₀" href="#NeXLCore.a₀"><code>NeXLCore.a₀</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">a₀ : Bohr radius (in cm)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.ksubshells" href="#NeXLCore.ksubshells"><code>NeXLCore.ksubshells</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">ksubshells</code></pre><p>All K sub-shells ( K )</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.ktransitions" href="#NeXLCore.ktransitions"><code>NeXLCore.ktransitions</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">ktransitions</code></pre><p>A complete list of all the K-shell transitions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.lsubshells" href="#NeXLCore.lsubshells"><code>NeXLCore.lsubshells</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">lsubshells</code></pre><p>All L sub-shells ( L1, L2, L3 )</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.ltransitions" href="#NeXLCore.ltransitions"><code>NeXLCore.ltransitions</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">ltransitions</code></pre><p>A complete list of all the L-shell transitions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.msubshells" href="#NeXLCore.msubshells"><code>NeXLCore.msubshells</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">msubshells</code></pre><p>All M sub-shells ( M1, M2,.., M5 )</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.mtransitions" href="#NeXLCore.mtransitions"><code>NeXLCore.mtransitions</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">mtransitions</code></pre><p>A complete list of all the M-shell transitions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.mₑ" href="#NeXLCore.mₑ"><code>NeXLCore.mₑ</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>mₑ : Electron rest mass (in eV)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.nsubshells" href="#NeXLCore.nsubshells"><code>NeXLCore.nsubshells</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">nsubshells</code></pre><p>All N sub-shells ( N1, N2,.., N7 ) ]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.ntransitions" href="#NeXLCore.ntransitions"><code>NeXLCore.ntransitions</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">ntransitions</code></pre><p>A complete list of all the N-shell transitions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.osubshells" href="#NeXLCore.osubshells"><code>NeXLCore.osubshells</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">osubshells</code></pre><p>All O sub-shells  ( O1, O2,.., O9 )</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.otransitions" href="#NeXLCore.otransitions"><code>NeXLCore.otransitions</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">otransitions</code></pre><p>A complete list of all the O-shell transitions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.transitionsbygroup" href="#NeXLCore.transitionsbygroup"><code>NeXLCore.transitionsbygroup</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">transitionsbygroup</code></pre><p>A Dict{String,Tuple{Transition}} mapping group name into a list of transitions. Keys are &quot;K&quot;,&quot;L&quot;,&quot;M&quot;,&quot;N&quot;,&quot;O&quot; and &quot;Kα&quot;, &quot;Ka&quot;, &quot;Kβ&quot;, &quot;Kb&quot; and &quot;Kother&quot;.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.transitionsbyshell" href="#NeXLCore.transitionsbyshell"><code>NeXLCore.transitionsbyshell</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">transitionsbyshell</code></pre><p>A Dict{Char,Tuple{Transition}} mapping shell name into a list of transitions. Keys are Shell objects.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.AFtoNMF" href="#NeXLCore.AFtoNMF"><code>NeXLCore.AFtoNMF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AFtoNMF</code></pre><p>Converts atomic fraction into mass fraction - since the results in by necessity normalized, both the MassFractionLabel and NormMassFractionLabel versions are populated with identical information.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.AtomicFraction" href="#NeXLCore.AtomicFraction"><code>NeXLCore.AtomicFraction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Naive atomic fraction material Z model</p><p>For more details see Mean Z algorithm in J.J. Donovan, N.E. Pingitore, Microsc. Microanal. 2002 ; 8 , 429 (also see Microsc. Microanal. 27 (Suppl 1), 2021))</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.AtomicSubShell" href="#NeXLCore.AtomicSubShell"><code>NeXLCore.AtomicSubShell</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AtomicSubShell</code></pre><p>Represents a specific ground-state occupied sub-shell in a specific element.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.BackscatterCoefficient" href="#NeXLCore.BackscatterCoefficient"><code>NeXLCore.BackscatterCoefficient</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">η(::Type{&lt;:BackscatterCoefficient}, elm::Element, e0::Real)</code></pre><p>Abstract type to represent backscatter coefficient algorithms.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Berger1982" href="#NeXLCore.Berger1982"><code>NeXLCore.Berger1982</code></a> — <span class="docstring-category">Type</span></header><section><div><p>@techreport{berger1982national,   title={National Bureau of Standards, Report NBSIR 82-2550},   author={Berger, MJ and Seltzer, SM},   journal={NBS, Washington, DC},   year={1982},   url={https://nvlpubs.nist.gov/nistpubs/Legacy/IR/nbsir82-2550A.pdf} }</p><p>According to B&amp;S &quot;The continuous-slowing-down approximation, i.e., the use of a stopping power to describe the gradual energy loss along the electron track, ceases to be meaningful at energies below several hundred eV.&quot;</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Bethe" href="#NeXLCore.Bethe"><code>NeXLCore.Bethe</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The Bethe algorithm of kinetic energy loss by electrons.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.BetheEnergyLoss" href="#NeXLCore.BetheEnergyLoss"><code>NeXLCore.BetheEnergyLoss</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An abstract type to describe kinetic energy loss by electrons. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Bloch1933" href="#NeXLCore.Bloch1933"><code>NeXLCore.Bloch1933</code></a> — <span class="docstring-category">Type</span></header><section><div><p>@article{von1933bremsvermogen,   title={Bremsverm{&quot;o}gen von Atomen mit mehreren Elektronen (Braking capabilities of multi-electron atoms)},   author={von Bloch, F},   journal={Z. Phys},   volume={81},   pages={363},   year={1933} }</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Brizuela1990" href="#NeXLCore.Brizuela1990"><code>NeXLCore.Brizuela1990</code></a> — <span class="docstring-category">Type</span></header><section><div><p>@article{brizuela1990study,   title={Study of mean excitation energy and K-shell effect for electron probe microanalysis},   author={Brizuela, Horacio and Riveros, Jos{&#39;e} Alberto},   journal={X-Ray Spectrometry},   volume={19},   number={4},   pages={173–176},   year={1990},   publisher={Wiley Online Library} }</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Browning1991" href="#NeXLCore.Browning1991"><code>NeXLCore.Browning1991</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Browning&#39;s scattering cross section</p><p>Appl. Phys. Lett. 58, 2845 (1991); https://doi.org/10.1063/1.104754</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Browning1994" href="#NeXLCore.Browning1994"><code>NeXLCore.Browning1994</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Browning&#39;s scattering cross section according to a draft 1994 article</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Castellano2004a" href="#NeXLCore.Castellano2004a"><code>NeXLCore.Castellano2004a</code></a> — <span class="docstring-category">Type</span></header><section><div><p>@article{castellano2004analytical,   title={Analytical model for the bremsstrahlung spectrum in the 0.25–20 keV photon energy range},   author={Castellano, Gustavo and Osan, Janos and Trincavelli, Jorge},   journal={Spectrochimica Acta Part B: Atomic Spectroscopy},   volume={59},   number={3},   pages={313–319},   year={2004},   publisher={Elsevier} }</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.CharXRay" href="#NeXLCore.CharXRay"><code>NeXLCore.CharXRay</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CharXRay</code></pre><p>Represents a specific known characteristic X-ray in a specific element.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.DefaultStageMapping" href="#NeXLCore.DefaultStageMapping"><code>NeXLCore.DefaultStageMapping</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The <code>DefaultStageMapping</code> assumes a matching Cartesian coordinate system for both the stage and image.  It only assumes <code>:X</code>, <code>:Y</code> stage motion.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Donovan2002" href="#NeXLCore.Donovan2002"><code>NeXLCore.Donovan2002</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Donovan&#39;s recommended material Z model</p><p>For more details see Mean Z algorithm in J.J. Donovan, N.E. Pingitore, Microsc. Microanal. 2002 ; 8 , 429 (also see Microsc. Microanal. 27 (Suppl 1), 2021))</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.ElasticFraction" href="#NeXLCore.ElasticFraction"><code>NeXLCore.ElasticFraction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Elastic fraction material Z model</p><p>For more details see Mean Z algorithm in J.J. Donovan, N.E. Pingitore, Microsc. Microanal. 2002 ; 8 , 429 (also see Microsc. Microanal. 27 (Suppl 1), 2021))</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.ElasticScatteringCrossSection" href="#NeXLCore.ElasticScatteringCrossSection"><code>NeXLCore.ElasticScatteringCrossSection</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Algorithms implementing the elastic scattering cross-section</p><pre><code class="nohighlight hljs">σₜ(::Type{ScreenedRutherford}, elm::Element, E::Float64)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.ElectronFraction" href="#NeXLCore.ElectronFraction"><code>NeXLCore.ElectronFraction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Electronic fraction material Z model</p><p>For more details see Mean Z algorithm in J.J. Donovan, N.E. Pingitore, Microsc. Microanal. 2002 ; 8 , 429 (also see Microsc. Microanal. 27 (Suppl 1), 2021))</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.ElementByDifference" href="#NeXLCore.ElementByDifference"><code>NeXLCore.ElementByDifference</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ElementByDifference</code></pre><p>Computes one element as the different between a sum of 1.0 mass fraction.  If the sum of the other element&#39;s mass fraction is already 1.0 or larger, returns zero.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.ElementByStoichiometry" href="#NeXLCore.ElementByStoichiometry"><code>NeXLCore.ElementByStoichiometry</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ElementByStoichiometry</code></pre><p>Computes the mass-fraction of an element which is related by stoichiometric rules (valence-rules) to the other elements in the material.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Film" href="#NeXLCore.Film"><code>NeXLCore.Film</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A structure defining a thin film or layer of a Material.</p><p>f = Film(pure(n&quot;C&quot;), 2.0e-7)  # 2 nm of nominal Calculated material(f) =&gt; pure C thickness(f) =&gt; 2.0e-7 massthickness(f) =&gt; 3.642e-7 g/cm²</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Jensen1937" href="#NeXLCore.Jensen1937"><code>NeXLCore.Jensen1937</code></a> — <span class="docstring-category">Type</span></header><section><div><p>@article{jensen1937eigenschwingungen,   title={Eigenschwingungen eines fermi-gases und anwendung auf die blochsche bremsformel f{&quot;u}r schnelle teilchen},   author={Jensen, Hans},   journal={Zeitschrift f{&quot;u}r Physik},   volume={106},   number={9-10},   pages={620–632},   year={1937},   publisher={Springer} }</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.JoyLuo" href="#NeXLCore.JoyLuo"><code>NeXLCore.JoyLuo</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The Joy-Luo algorithm of Bethe kinetic energy loss by electrons. SCANNING Vol. 11, 176-180 (1989) </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.KRatio" href="#NeXLCore.KRatio"><code>NeXLCore.KRatio</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KRatio(
    xray::CharXRay,
    unkProps::Dict{Symbol,&lt;:Any},
    stdProps::Dict{Symbol,&lt;:Any},
    standard::Material,
    kratio::AbstractFloat,
)</code></pre><p>The k-ratio is the ratio of two similar intensity measurements - one on  a material of unknown composition and one on a standard with known  composition. Each measurement has properties like :BeamEnergy (req),  :TakeOffAngle (req), :Coating (opt) that characterize the measurement.   A minimal set of properties includes:</p><p>Properties: (These <code>Symbol</code>s are intentionally the same used in NeXLSpectrum)</p><pre><code class="nohighlight hljs">:BeamEnergy incident beam energy in eV
:TakeOffAngle in radians
:Coating A NeXLCore.Film object or Film[] detailing a conductive coating</code></pre><p>Some algorithms may require additional properties.</p><p>k-ratios are associated with characteristic X-rays (<code>CharXRay</code>) from a single element. WDS k-ratios are typically associated with a single <code>CharXRay</code> while EDS measurements may be associated with many <code>CharXRay</code> that are similar in energy. k-ratios are always relative to another material.  Usually the composition of this <code>Material</code> is well-known.  However, when a k-ratio is restandardized, it is possible for the intermediate material to be less well-known.</p><p>Methods:</p><pre><code class="nohighlight hljs">&gt; element(kr)
&gt; xrays(kr)
&gt; standard(kr)
&gt; elms(KRatioBase[...])
&gt; NeXLUncertainties.value(kr::KRatio)
&gt; NeXLUncertainties.σ(kr::KRatio)
&gt; nonnegk(kr::KRatio)
&gt; Statistics.mean(krs::AbstractVector{KRatio})::UncertainValue
&gt; Base.getindex(krs::AbstractVector{KRatio}, cxr::CharXRay)
&gt; strip(krs::AbstractVector{KRatio}, els::Element...)::Vector{KRatio}
&gt; asa(::Type{DataFrame}, krs::AbstractVector{KRatio})::DataFrame</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.KRatioBase" href="#NeXLCore.KRatioBase"><code>NeXLCore.KRatioBase</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The members in common between KRatio and KRatios</p><pre><code class="nohighlight hljs">&gt; element(kr)
&gt; xrays(kr)
&gt; standard(kr)
&gt; elms(KRatioBase[...])</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.KRatios" href="#NeXLCore.KRatios"><code>NeXLCore.KRatios</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>KRatios</code> represents the hyper-spectral equivalent of the KRatio type.  Each pixel in the <code>KRatios</code> object must be characterized by the same unknown and standard properties, the same X-ray lines and the other properties.</p><p>Methods:</p><pre><code class="nohighlight hljs">&gt; Base.getindex(krs::KRatios, idx::Int...)
&gt; Base.getindex(krs::KRatios, ci::CartesianIndex)
&gt; Base.size(krs::KRatios, [idx::Int])
&gt; Base.CartesianIndices(krs::KRatios)
&gt; normalizek(krs::AbstractVector{&lt;:KRatios}; norm::Float32=1.0f)::Vector{KRatios}
&gt; normalizek(krs::AbstractVector{KRatio}; norm::Float32=1.0f)::Vector{KRatio}
&gt; brightest(krs::Union{KRatios, KRatio})
&gt; colorize(krs::AbstractVector{&lt;:KRatios}, red::Element, green::Element, blue::Element, normalize=:All[|:Each])
&gt; colorize(krs::AbstractVector{&lt;:KRatios}, elms::AbstractVector{Element}, normalize=:All)
&gt; Base.getindex(krs::AbstractVector{&lt;:KRatios}, elm::Element) # Gray scale image
&gt; Base.getindex(krs::AbstractVector{&lt;:KRatios}, red::Element, green::Element)  # Red-green image
&gt; Base.getindex(krs::AbstractVector{&lt;:KRatios}, red::Element, green::Element, blue::Element) # RGB image</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Kramers1923" href="#NeXLCore.Kramers1923"><code>NeXLCore.Kramers1923</code></a> — <span class="docstring-category">Type</span></header><section><div><p>@article{kramers1923,     author = { Kramers, H. A. },     title = {XCIII. On the theory of X-ray absorption and of the continuous X-ray spectrum},     journal = {The London, Edinburgh, and Dublin Philosophical Magazine and Journal of Science},     volume = {46},     number = {275},     pages = {836-871},     year  = {1923},     publisher = {Taylor &amp; Francis},     doi = {10.1080/14786442308565244},     URL = { https://doi.org/10.1080/14786442308565244 },     eprint = { https://doi.org/10.1080/14786442308565244} }</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Lifshin1974" href="#NeXLCore.Lifshin1974"><code>NeXLCore.Lifshin1974</code></a> — <span class="docstring-category">Type</span></header><section><div><p>@InProceedings{ lifshin1974,     author={Lifshin, E.},     journal=&quot;Proceedings Ninth National Conference on Electron Probe Analysis, Ottowa, CA&quot;,     year={1974},     volume={174},     number={3}, }</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Liljequist1989" href="#NeXLCore.Liljequist1989"><code>NeXLCore.Liljequist1989</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Liljequist&#39;s simple refinement of the basic ScreenedRutherford algorithm.</p><p>Journal of Applied Physics, 65, 24-31 (1989) as corrected in J. Appl. Phys. 68 (7) 3061-3065 (1990)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.LoveScott1978η" href="#NeXLCore.LoveScott1978η"><code>NeXLCore.LoveScott1978η</code></a> — <span class="docstring-category">Type</span></header><section><div><p>@article{Love_1978, 	doi = {10.1088/0022-3727/11/10/002}, 	url = {https://doi.org/10.1088%2F0022-3727%2F11%2F10%2F002}, 	year = 1978, 	month = {jul}, 	publisher = {{IOP} Publishing}, 	volume = {11}, 	number = {10}, 	pages = {1369–1376}, 	author = {G Love and V D Scott}, 	title = {Evaluation of a new correction procedure for quantitative electron probe microanalysis}, 	journal = {Journal of Physics D: Applied Physics}, 	abstract = {A new correction procedure for converting electron-probe microanalysis measurements into 	true weight concentration is proposed. It incorporates a new atomic number correction and an absorption 	correction based upon Bishop&#39;s model (1974). Unlike earlier treatments the model does not have to 	rely upon any empirical optimisation of input parameters. The correction procedure has been tested by 	applying it to a wide range of microanalysis data including light-element results, and it is shown to 	give greater accuracy than the established methods.} }</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.MFtoNMF" href="#NeXLCore.MFtoNMF"><code>NeXLCore.MFtoNMF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MFtoNMF</code></pre><p>Mass fraction to normalized mass fraction measurement model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.MatStats" href="#NeXLCore.MatStats"><code>NeXLCore.MatStats</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MatStats</code></pre><p>Computes the mean atomic number (MeanZ) and mean atomic weight (MeanAz).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Material" href="#NeXLCore.Material"><code>NeXLCore.Material</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Holds basic data about a material including name, composition in mass fraction and optional propreties.</p><p>By default, Material assumes nominal terrestrial atomic weights.  However, it is possible to assign custom atomic weights on a per element-basis for non-terrestrial materials.</p><p>The mass fraction and atomic weight are immutable but the <code>Properties</code> can be modified.</p><pre><code class="nohighlight hljs">Material(
    name::AbstractString,
    massfrac::AbstractDict{Element,U},
    atomicweights::AbstractDict{Element,V} = Dict{Element,Float64}(),
    properties::AbstractDict{Symbol,Any} = Dict{Symbol,Any}(),
) where { U &lt;: AbstractFloat, V &lt;: AbstractFloat }</code></pre><p><strong>Properties</strong></p><pre><code class="nohighlight hljs">:Density # Density in g/cm³
:Description # Human friendly
:Pedigree #  Quality indicator for compositional data (&quot;SRM-XXX&quot;, &quot;CRM-XXX&quot;, &quot;NIST K-Glass&quot;, &quot;Stoichiometry&quot;, &quot;Wet-chemistry by ???&quot;, &quot;WDS by ???&quot;, &quot;???&quot;)
:Conductivity = :Insulator | :Semiconductor | :Conductor
:OtherUserProperties # Other properties can be defined as needed</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Material-Tuple{Dict{String, Any}}" href="#NeXLCore.Material-Tuple{Dict{String, Any}}"><code>NeXLCore.Material</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Material(d::Dict)</code></pre><p>Construct a <code>Material</code> from a <code>Dict</code> created by <code>NeXLUncertainties.asa(Dict, mat::Material)</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.MaterialFractionLabel" href="#NeXLCore.MaterialFractionLabel"><code>NeXLCore.MaterialFractionLabel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MaterialFraction</code></pre><p>This label represents the amount of a material <code>constituent</code> in <code>material</code> in a material defined as the mixture of other materials.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.MaterialLabel" href="#NeXLCore.MaterialLabel"><code>NeXLCore.MaterialLabel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MaterialLabel</code></pre><p>The abstract type associated with <code>Label</code>s with <code>material</code> and <code>element</code> members.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Materials" href="#NeXLCore.Materials"><code>NeXLCore.Materials</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Materials(
    name::AbstractString,
    els::AbstractArray{Element},
    ::Type{U},
    dims::Tuple;
    atomicweights::AbstractDict{Element,V} = Dict{Element,Float64}(),
    properties::AbstractDict{Symbol,Any} = Dict{Symbol,Any}(),
) where {U&lt;:AbstractFloat, V&lt;:AbstractFloat}</code></pre><p>A type to represent the composition of multiple points as a complement to <code>KRatios</code> and <code>HyperSpectrum</code>. The data is stored in a much more memory efficient manner than <code>Array{Material}</code> would but can be accessed either by coordinate like <code>mats[1,2]</code> returning a <code>Material</code> or by element like <code>mats[n&quot;Fe&quot;]</code> returning an Array of mass fraction values.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.NeXLBremsstrahlung" href="#NeXLCore.NeXLBremsstrahlung"><code>NeXLCore.NeXLBremsstrahlung</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An abstract structure that implements</p><pre><code class="nohighlight hljs">NeXLCore.bremsstrahlung(::Type{&lt;:NeXLBremsstrahlung}, e::AbstractFloat, e0::AbstractFloat, elm::Element; kwargs...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.NeXLMeanIonizationPotential" href="#NeXLCore.NeXLMeanIonizationPotential"><code>NeXLCore.NeXLMeanIonizationPotential</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Algorithms that implement the mean ionization potential.  The mean ionization potential is the primary parameter in continuous slowing down models of electron energy loss in matter.  Electrons primarily lose energy through two mechanisms - 1) collision stopping power parameterized by J, the mean ionization potential; and 2) Bremsstrahlung production.  Two or three orders of magnitude more energy is lost to collisional loss so collisional loss dominates the process and losses due to Bremsstrahlung production are insignificant relative to the uncertainty in collisional loss.</p><p>Implement this:</p><pre><code class="nohighlight hljs">J(::Type{&lt;:NeXLMeanIonizationPotential}, z)  # in eV</code></pre><p>Also provided:</p><pre><code class="nohighlight hljs">J(::Type{&lt;:NeXLMeanIonizationPotential}, elm::Element)  # in eV</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.NormalizeByShell" href="#NeXLCore.NormalizeByShell"><code>NeXLCore.NormalizeByShell</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>NormalizeByShell</code> normalizes the sum of all the weights associated with a shell to unity. Example: </p><pre><code class="nohighlight hljs">sum(cxr=&gt;weight(NormalizeByShell, cxr), characteristic(n&quot;Fe&quot;, ltransitions))==1.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.NormalizeBySubShell" href="#NeXLCore.NormalizeBySubShell"><code>NeXLCore.NormalizeBySubShell</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>NormalizeBySubShell</code> normalizes the sum of all the weights associated with a sub-shell to unity.</p><p>Example: </p><pre><code class="nohighlight hljs">sum(cxr=&gt;weight(NormalizeBySubShell, cxr), characteristic(n&quot;Fe&quot;, ltransitions))==1.0+1.0+1.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.NormalizeRaw" href="#NeXLCore.NormalizeRaw"><code>NeXLCore.NormalizeRaw</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>NormalizeRaw</code> returns the raw transition probabilities - The probability of seeing the specified X-ray given one ionization of the specified shell.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.NormalizeToUnity" href="#NeXLCore.NormalizeToUnity"><code>NeXLCore.NormalizeToUnity</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>NormalizeToUnity</code> normalizes intensities such that the most intense line in each shell is 1.0.</p><p>Example:      weight(NormalizeToUnity, n&quot;Fe L3-M5&quot;)==1.0     max(cxr=&gt;weight(NormalizeBySubShell, cxr), characteristic(n&quot;Fe&quot;, ltransitions))==1.0</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Particle" href="#NeXLCore.Particle"><code>NeXLCore.Particle</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Particle represents a type that may be simulated using a transport Monte Carlo.  It must provide these methods:</p><pre><code class="nohighlight hljs">position(el::Particle)::Position
previous(el::Particle)::Position
energy(el::Particle)::Float64</code></pre><p>The position of the current and previous elastic scatter locations which are stored in that Particle type.</p><pre><code class="nohighlight hljs">T(prev::Position, curr::Position, energy::Energy) where {T &lt;: Particle }
T(el::T, 𝜆::Float64, 𝜃::Float64, 𝜑::Float64, ΔE::Float64) where {T &lt;: Particle }</code></pre><p>Two constructors: One to create a defined Particle and the other to create a new Particle based off another which is translated by <code>λ</code> at a scattering angle (<code>θ</code>, <code>ϕ</code>) which energy change of <code>ΔE</code></p><pre><code class="nohighlight hljs">transport(pc::T, mat::Material)::NTuple{4, Float64} where {T &lt;: Particle }</code></pre><p>A function that generates the values of ( <code>λ</code>, <code>θ</code>, <code>ϕ</code>, <code>ΔE</code>) for the specified <code>Particle</code> in the specified <code>Material</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Position" href="#NeXLCore.Position"><code>NeXLCore.Position</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Position</code> : A point in 3-D.  Ultimately, derived from StaticArray.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Pouchou1991η" href="#NeXLCore.Pouchou1991η"><code>NeXLCore.Pouchou1991η</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The model for Pouchou&#39;s 1991 model (&quot;Green Book&quot;) of the BackscatterCoefficient.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.RectangularShape" href="#NeXLCore.RectangularShape"><code>NeXLCore.RectangularShape</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The MonteCarlo uses the shapes defined in GeometryBasics basics as the foundation for its  sample construction mechanisms.  However, GeometryBasics basics does not provide all the  necessary methods.  Three additional methods are </p><pre><code class="nohighlight hljs">isinside(r::Shape, pos::Position)</code></pre><p>Is <code>pos</code> strictly inside <code>r</code>?</p><pre><code class="nohighlight hljs">intersection(r::Shape, pos0::Particle, pos1::Particle)::Float64</code></pre><p>Return a number <code>f</code> which represent the fraction of the distance from <code>pos0</code> to <code>pos1</code> that first intersects the <code>Shape</code> <code>r</code>.  The intersection point will equal <code>pos0 .+ f*(pos1 .- pos0)</code>. If <code>f</code> is between 0.0 and 1.0 then the intersection is on the interval between <code>pos0</code> and <code>pos1</code>. If the ray from <code>pos0</code> towards <code>pos2</code> does not intersect <code>r</code> then this function returns Inf64.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Reed1975" href="#NeXLCore.Reed1975"><code>NeXLCore.Reed1975</code></a> — <span class="docstring-category">Type</span></header><section><div><p>@article{reed1975shape,   title={The shape of the continuous X-ray spectrum and background corrections for energy-dispersive electron microprobe analysis},   author={Reed, SJB},   journal={X-Ray Spectrometry},   volume={4},   number={1},   pages={14–17},   year={1975},   publisher={Wiley Online Library} }</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Region" href="#NeXLCore.Region"><code>NeXLCore.Region</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Region</code></pre><p>A <code>Region</code> combines a geometric primative and a <code>Material</code> (with <code>:Density</code> property) and may fully contain zero or more child <code>Region</code>s.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Reimer1998" href="#NeXLCore.Reimer1998"><code>NeXLCore.Reimer1998</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The model for Reimer&#39;s model of the BackscatterCoefficient.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.ScreenedRutherfordType" href="#NeXLCore.ScreenedRutherfordType"><code>NeXLCore.ScreenedRutherfordType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Basic screened Rutherford algorithm where V(r) = (-Ze²/r)exp(-r/R) where R=a₀Z⁻¹/³ is solved using the first Born approximation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Shell" href="#NeXLCore.Shell"><code>NeXLCore.Shell</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Shell</code></pre><p>Represents the K, L, M, N etc atomic shell</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Small1987" href="#NeXLCore.Small1987"><code>NeXLCore.Small1987</code></a> — <span class="docstring-category">Type</span></header><section><div><p>@article{small1987modeling,   title={Modeling of the bremsstrahlung radiation produced in pure-element targets by 10–40 keV electrons},   author={Small, John A and Leigh, Stefan D and Newbury, Dale E and Myklebust, Robert L},   journal={Journal of applied physics},   volume={61},   number={2},   pages={459–469},   year={1987},   publisher={American Institute of Physics} }</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Smith1975" href="#NeXLCore.Smith1975"><code>NeXLCore.Smith1975</code></a> — <span class="docstring-category">Type</span></header><section><div><p>@article{ smithgoldtomlinson1975     title=&quot;The atomic number dependence of the X‐ray continuum intensity and the practical calculation of background in energy dispersive electron microprobe analysis&quot;,     author = {Smith, D. G. W.  and Gold, C. M. and Tomlinson, D. A.},     journal={X-ray Spectrometry},     volume={4},     pages={149-156},     year={1975},     doi={10.1002/xrs.1300040311}, }</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Springer1967" href="#NeXLCore.Springer1967"><code>NeXLCore.Springer1967</code></a> — <span class="docstring-category">Type</span></header><section><div><p>@article{springer1967electron,   title={Electron Transport in Amorphous Materials. I},   author={Springer, Bernard},   journal={Physical Review},   volume={154},   number={3},   pages={614},   year={1967},   publisher={APS} }</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Sternheimer1964" href="#NeXLCore.Sternheimer1964"><code>NeXLCore.Sternheimer1964</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Cited personal communication in @article{berger196410,   title={10. Tables of energy-losses and ranges of electrons and positrons},   author={Berger, M and Seltzer, S},   journal={Studies in penetration of charged particles in matter},   number={39},   pages={205},   year={1964} }</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.SubShell" href="#NeXLCore.SubShell"><code>NeXLCore.SubShell</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SubShell</code></pre><p>Represents one of the various subshells in an atom.  (See <code>AtomicSubShell</code> to combine the element with a <code>SubShell</code>.) Member data items are index::Int where 1=&gt;K, 2=&gt;L1, ..., 36=&gt;P11. Construct using SubShell(name::AbstractString) where name = &quot;K&quot;, &quot;L1&quot;...,&quot;P11&quot;</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Tomlin1963" href="#NeXLCore.Tomlin1963"><code>NeXLCore.Tomlin1963</code></a> — <span class="docstring-category">Type</span></header><section><div><p>@article{Tomlin_1963, 	doi = {10.1088/0370-1328/82/3/118}, 	url = {https://doi.org/10.1088%2F0370-1328%2F82%2F3%2F118}, 	year = 1963, 	month = {sep}, 	publisher = {{IOP} Publishing}, 	volume = {82}, 	number = {3}, 	pages = {465–466}, 	author = {S G Tomlin}, 	title = {The Back-scattering of Electrons from Solids}, 	journal = {Proceedings of the Physical Society}, 	abstract = {Archard&#39;s diffusion model of electron back-scattering is discussed on the basis of a 	result obtained by Tomlin and Metchnik in 1963 in their treatment of x-ray emission intensities. 	The resulting simple formula for the back-scattering coefficient is in reasonably good agreement 	with measured values.} }</p><p>The implementation adapted to not return negative numbers for z&lt;5.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Transition" href="#NeXLCore.Transition"><code>NeXLCore.Transition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Transition</code></pre><p>Represents an inner and outer shell that describe an X-ray transition. Only transitions for which one or more element has a characteristic x-ray are supported according to the default line weight database (weight &gt; 0 for one or more Z). This structure does not contain the Element information necessary to specify a characteristic X-ray.</p><p>Data items:</p><pre><code class="nohighlight hljs">innerShell::SubShell
outerShell::SubShell</code></pre><p>Example:</p><pre><code class="nohighlight hljs">tr1 = Transition(n&quot;K1&quot;,n&quot;L3&quot;)
tr2   = Transition(SubShell(1),SubShell(4))
@assert tr1==tr2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Trincavelli1997" href="#NeXLCore.Trincavelli1997"><code>NeXLCore.Trincavelli1997</code></a> — <span class="docstring-category">Type</span></header><section><div><p>@article{trincavelli1998model,   title={Model for the bremsstrahlung spectrum in EPMA. Application to standardless quantification},   author={Trincavelli, Jorge and Castellano, Gustavo and Riveros, J Alberto},   journal={X-Ray Spectrometry: An International Journal},   volume={27},   number={2},   pages={81–86},   year={1998},   publisher={Wiley Online Library} }</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.WeightNormalization" href="#NeXLCore.WeightNormalization"><code>NeXLCore.WeightNormalization</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The abstract type <code>WeightNormalization</code> is the base type for structs identifying the various different useful ways in which line weight (relaxation) data can be represented.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Wilson1941" href="#NeXLCore.Wilson1941"><code>NeXLCore.Wilson1941</code></a> — <span class="docstring-category">Type</span></header><section><div><p>@article{wilson1941range,   title={Range and ionization measurements on high speed protons},   author={Wilson, Robert R},   journal={Physical Review},   volume={60},   number={11},   pages={749},   year={1941},   publisher={APS} }</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.XRay" href="#NeXLCore.XRay"><code>NeXLCore.XRay</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An abstract type for X-rays like <code>CharXRay</code> and <code>Continuum</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Zeller1973" href="#NeXLCore.Zeller1973"><code>NeXLCore.Zeller1973</code></a> — <span class="docstring-category">Type</span></header><section><div><p>@article{coulon1973determination,   title={D{&#39;e}termination th{&#39;e}oretique du facteur de r{&#39;e}trodiffusion en microanalyse par {&#39;e}mission X},   author={Coulon, J and Zeller, C},   journal={CR Acad Sci Paris},   volume={276},   pages={215–218},   year={1973} }</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{Material}, AbstractString}" href="#Base.convert-Tuple{Type{Material}, AbstractString}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.convert(::Type{Material}, str::AbstractString)</code></pre><p>Convert a DTSA-II style string into a material.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.delete!-Tuple{SQLite.DB, Type{Material}, AbstractString}" href="#Base.delete!-Tuple{SQLite.DB, Type{Material}, AbstractString}"><code>Base.delete!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.delete!(db::SQLite.DB, ::Type{Material}, matname::AbstractString)</code></pre><p>Delete the named <code>Material</code> from the database.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findall-Tuple{SQLite.DB, Type{Material}, AbstractString}" href="#Base.findall-Tuple{SQLite.DB, Type{Material}, AbstractString}"><code>Base.findall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.findall(db::SQLite.DB, ::Type{Material}, like::AbstractString)::Vector{String}</code></pre><p>Returns the names of all <code>Material</code>s in the database which match the <code>like</code> string.</p><p><code>like</code> uses SQL like syntax where <code>%</code> and <code>_</code> have special meanings. Searches are case-insenstive.</p><ul><li>&#39;%&#39; matches zero or more characters </li><li>&#39;_&#39; matches one character</li></ul><p>Using the RUFF database:</p><ul><li><code>findall(db, Material, &quot;Al%&quot;)</code> matches all 37 materials starting with the letters &#39;a&#39; then &#39;l&#39; (case-insenstive).</li><li><code>findall(db, Material, &quot;Al%ite&quot;)</code> matches all materials starting with the letters &#39;a&#39; then &#39;l&#39; and ending with &#39;ite&#39;.</li><li><code>findall(db, Material, &quot;Al__rsite&quot;)</code> matches &quot;Alforsite&quot; and &quot;Alpersite&quot; while <code>findall(db, Material, &quot;Al%rsite&quot;)</code> matches these two plus <code>Alarsite</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findall-Tuple{SQLite.DB, Type{Material}, Vararg{Pair{Element, &lt;:Tuple{var&quot;#s81&quot;, var&quot;#s79&quot;} where {var&quot;#s81&quot;&lt;:Real, var&quot;#s79&quot;&lt;:Real}}}}" href="#Base.findall-Tuple{SQLite.DB, Type{Material}, Vararg{Pair{Element, &lt;:Tuple{var&quot;#s81&quot;, var&quot;#s79&quot;} where {var&quot;#s81&quot;&lt;:Real, var&quot;#s79&quot;&lt;:Real}}}}"><code>Base.findall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.findall(db::SQLite.DB, ::Type{Material}, prs::Pair{Element, &lt;:Tuple{&lt;:Real,&lt;:Real}}...)::Vector{&lt;:Material}
Base.findall(db::SQLite.DB, ::Type{Material}, filt::Dict{Element, &lt;:Tuple{&lt;:Real,&lt;:Real}})::Vector{&lt;:Material}
Base.findall(db::SQLite.DB, mat::Material, tol::Float64)::Vector{&lt;:Material}</code></pre><p>Returns all the <code>Material</code>s in the database that have mass fractions for the specified elements within a range. The first two versions take a collection of <code>Element</code>, <code>Tuple</code> pairs that specify the range of mass fractions for each element.</p><p>Examples:</p><pre><code class="nohighlight hljs">julia&gt; findall(db, Material, Dict(n&quot;Bi&quot;=&gt;(0.1,0.5), n&quot;Cu&quot;=&gt;(0.2,0.3)))
3-element Vector{Material{UncertainValue, Float64}}:
 Favreauite[Bi=0.1488,Se=0.2249,Cu=0.2715,Pb=0.1475,O=0.2051,H=0.0022]
 Miharaite[Bi=0.2275,Cu=0.2767,S=0.2094,Fe=0.0608,Pb=0.2256]
 Mrázekite[Bi=0.4641,Cu=0.2117,P=0.0688,O=0.2487,H=0.0067]

julia&gt; findall(db, mat&quot;NaAlSi3O8&quot;, 0.01)
4-element Vector{Material{UncertainValue, Float64}}:
 Albite[Al=0.1029,Na=0.0877,Si=0.3213,O=0.4881]
 Kumdykolite[Al=0.1029,Na=0.0877,Si=0.3213,O=0.4881]
 Lingunite[Al=0.1029,Na=0.0877,Si=0.3213,O=0.4881]
 Monalbite[Al=0.1029,Na=0.0877,Si=0.3213,O=0.4881]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findfirst-Tuple{AbstractVector{&lt;:NeXLCore.KRatioBase}, CharXRay}" href="#Base.findfirst-Tuple{AbstractVector{&lt;:NeXLCore.KRatioBase}, CharXRay}"><code>Base.findfirst</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.findfirst(krs::AbstractVector{&lt;:KRatioBase}, cxr::CharXRay)</code></pre><p>Find the first KRatio or KRatios in which the .xrays field contains the cxr::CharXRay.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.haskey-Tuple{Material, Element}" href="#Base.haskey-Tuple{Material, Element}"><code>Base.haskey</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">haskey(mat::Material, elm::Element)
haskey(mat::Material, z::Int)</code></pre><p>Does this material contain this element?</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.haskey-Tuple{Material, Symbol}" href="#Base.haskey-Tuple{Material, Symbol}"><code>Base.haskey</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">haskey(mat::Material, sym::Symbol)</code></pre><p>Does this material have this property defined?</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.haskey-Tuple{SQLite.DB, Type{Material}, AbstractString}" href="#Base.haskey-Tuple{SQLite.DB, Type{Material}, AbstractString}"><code>Base.haskey</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.haskey(db::SQLite.DB, ::Type{Material}, matname::AbstractString)::Bool</code></pre><p>Is a <code>Material</code> named <code>matname</code> in the database?</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{Material, Material}" href="#Base.isapprox-Tuple{Material, Material}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.isapprox(mat1::Material, mat2::Material; atol = 1.0e-4)</code></pre><p>Are these Material(s) equivalent to within <code>atol</code>?</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.keys-Tuple{Material}" href="#Base.keys-Tuple{Material}"><code>Base.keys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.keys(mat::Material)</code></pre><p>Return an interator over the elements in the Material.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.parse-Tuple{Type{AtomicSubShell}, AbstractString}" href="#Base.parse-Tuple{Type{AtomicSubShell}, AbstractString}"><code>Base.parse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.parse(::Type{SubShell}, name::AbstractString)
subshell(name::AbstractString)</code></pre><p>Parse an SubShell from a string of the form &quot;K&quot;, &quot;L1&quot;, &quot;L2&quot;, ...</p><pre><code class="nohighlight hljs">Base.parse(::Type{AtomicSubShell}, str::AbstractString)::AtomicSubShell
atomicsubshell(str::AbstractString)::AtomicSubShell</code></pre><p>Parse an AtomicSubShell from a string of the form &quot;Fe K&quot; or &quot;U M5&quot;.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.parse-Tuple{Type{Transition}, AbstractString}" href="#Base.parse-Tuple{Type{Transition}, AbstractString}"><code>Base.parse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transition(str::AbstractString)::Transition</code></pre><p>Constructs a Transition structure from a string representation of the form &quot;K-L3&quot; or &quot;L3-M5&quot;.  Asserts if the transition is not a known transition.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rand" href="#Base.rand"><code>Base.rand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.rand(::Type{Material}, zs::AbstractUnitRange{Int}=1:20)::Material</code></pre><p>Generate a randomize material.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rand-Tuple{Type{&lt;:ScreenedRutherfordType}, Element, Float64}" href="#Base.rand-Tuple{Type{&lt;:ScreenedRutherfordType}, Element, Float64}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.rand(::Type{&lt;:ScreenedRutherfordType}, elm::Element, E::Float64)::Float64</code></pre><p>Draw an angle distributed according to the angular dependence of the differential screened Rutherford cross-section.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rand-Tuple{Type{&lt;:ScreenedRutherfordType}, Material, Float64}" href="#Base.rand-Tuple{Type{&lt;:ScreenedRutherfordType}, Material, Float64}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.rand(ty::Type{&lt;:ScreenedRutherfordType}, mat::Material, E::Float64)::NTuple{3, Float64}</code></pre><p>Returns a randomly selected elastic scattering event description.  The result is ( λ, θ, ϕ ) where  λ is a randomized mean free path for the first scattering event.  θ is a randomized scattering  angle on (0.0, π) and ϕ is a randomized azimuthal angle on [0, 2π).</p><p>The algorithm considers scattering by any element in the material and picks the shortest randomized  path.  This implementation depends on two facts: 1) We are looking for the first scattering event  so we consider all the elements and pick the one with the shortest path. 2) The process is memoryless.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.range" href="#Base.range"><code>Base.range</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">range(::Type{BetheEnergyLoss}, mat::Material, e0::Float64, inclDensity = true)</code></pre><p>Calculates the electron range using numeric quadrature of a BetheEnergyLoss algorithm.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.range" href="#Base.range"><code>Base.range</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">range(::Type{Kanaya1972}, mat::Material, e0::Float64, inclDensity = true)</code></pre><p>Calculates the Kanaya-Okayama electron range. Kanaya K, Okayama S (1972) Penetration and energy-loss theory of electrons in solid targets. J Appl Phys 5:43</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.read-Tuple{SQLite.DB, Type{Material}, Int64}" href="#Base.read-Tuple{SQLite.DB, Type{Material}, Int64}"><code>Base.read</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.read(db::SQLite.DB, ::Type{Material}, pkey::Int)::Material
Base.read(db::SQLite.DB, ::Type{Material}, matname::AbstractString)::Material</code></pre><p>Read a <code>Material</code> from the database by index or by name.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.similar-Tuple{Material{UncertainValue}, Integer}" href="#Base.similar-Tuple{Material{UncertainValue}, Integer}"><code>Base.similar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.similar(mat::Material{UncertainValue, &lt;:AbstractFloat}, n::Integer)::Vector{Material{UncertainValue,Float64}}</code></pre><p>Generate <code>n</code> Materials similar to <code>mat</code> using the uncertainties in <code>mat</code> as  your guide of dispersion.  The mass-fractions of <code>mat</code> must be defined as <code>UncertainValue</code>s.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.strip-Tuple{AbstractVector{KRatio}, Vararg{Element}}" href="#Base.strip-Tuple{AbstractVector{KRatio}, Vararg{Element}}"><code>Base.strip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">strip(krs::AbstractVector{KRatio}, els::Element...)::Vector{KRatio}</code></pre><p>Creates a new Vector{KRatio} containing all the KRatio objects in <code>krs</code> except those associated with the specified elements.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sum-Tuple{Dict{Material, &lt;:AbstractFloat}}" href="#Base.sum-Tuple{Dict{Material, &lt;:AbstractFloat}}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.sum(
  data::Dict{Material, &lt;:AbstractFloat};
  name::Union{AbstractString,Missing} = missing,
  properties::Dict{Symbol,Any} = Dict{Symbol,Any}(),
  density::Union{Missing,AbstractFloat} = missing,
  description::Union{Missing,AbstractString} = missing,
  pedigree::Union{Missing,AbstractString} = missing,
  conductivity::Union{Missing,Symbol} = missing, # :Conductor, :Semiconductor, :Insulator</code></pre><p>)::Material</p><p>Sum together proportions of various <code>Material</code> structs.  The dictionary defines the material and the mass fraction of that material.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sum-Tuple{Material, Material}" href="#Base.sum-Tuple{Material, Material}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.sum(
    mat1::Material,
    mat2::Material;
    name::Union{AbstractString,Missing} = missing,
    properties::Dict{Symbol,Any} = Dict{Symbol,Any}(),
    density::Union{Missing,AbstractFloat} = missing,
    description::Union{Missing,AbstractString} = missing,
    pedigree::Union{Missing,AbstractString} = missing,
    conductivity::Union{Missing,Symbol} = missing, # :Conductor, :Semiconductor, :Insulator
)::Material</code></pre><p>Construct a Material that represents the mass-fraction sum of mat1 and mat2. This function  is often used along with Base.:<em>(k::AbstractFloat, mat::Material)::Material to construct mixtures of compounds.  Ultimately, expressions like `mat&quot;0.5</em>Al2O3+0.5<em>MgO&quot;<code>or equivalently</code>0.5</em>mat&quot;Al2O3&quot;+0.5*mat&quot;MgO&quot;<code>are computed using</code>sum(...)`.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.write-Tuple{SQLite.DB, Type{Material}, Material}" href="#Base.write-Tuple{SQLite.DB, Type{Material}, Material}"><code>Base.write</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.write(db::SQLite.DB, ::Type{Material}, mat::Material)::Int</code></pre><p>Add a <code>Material</code> to the SQLite database.  Will not overwrite a previously define definition. To replace a definition, first <code>delete!(db, Material, matname)</code>. Returns the database key associated with the <code>Material</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Gadfly.plot" href="#Gadfly.plot"><code>Gadfly.plot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Gadfly.plot(sss::AbstractVector{SubShell}, mode=:EdgeEnergy|:FluorescenceYield; palette=NeXLPalette)</code></pre><p>Plot the edge energies/fluorescence yields associated with the specified vector of SubShell objects.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Gadfly.plot-Tuple{AbstractVector{Transition}}" href="#Gadfly.plot-Tuple{AbstractVector{Transition}}"><code>Gadfly.plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Gadfly.plot(transitions::AbstractVector{Transition}; mode=:Energy|:Weight, palette=NeXLPalette)</code></pre><p>Plot either the <code>:Energy</code> or <code>:Weight</code> associated with the specified transitions over the range of supported elements.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Gadfly.plot-Tuple{Type{&lt;:NeXLAlgorithm}, AbstractVector}" href="#Gadfly.plot-Tuple{Type{&lt;:NeXLAlgorithm}, AbstractVector}"><code>Gadfly.plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compareMACs(elm::Element; palette=NeXLPalette)</code></pre><p>Plot a comparison of the FFAST and Heinrich MAC tabulations for the specified Element or Material.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Gadfly.plot-Tuple{Type{&lt;:NeXLAlgorithm}, Union{Element, Material}}" href="#Gadfly.plot-Tuple{Type{&lt;:NeXLAlgorithm}, Union{Element, Material}}"><code>Gadfly.plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(alg::Type{&lt;:NeXLAlgorithm}, elm::Union{Element,Material}; palette = NeXLPalette, xmax=20.0e3)</code></pre><p>Plot a MAC tabulations for the specified Element or Material.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Ekₑ-Tuple{Unitful.Quantity}" href="#NeXLCore.Ekₑ-Tuple{Unitful.Quantity}"><code>NeXLCore.Ekₑ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Electron kinetic energy in eV for v in cm/s.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.J-Tuple{Type{&lt;:NeXLMeanIonizationPotential}, Material}" href="#NeXLCore.J-Tuple{Type{&lt;:NeXLMeanIonizationPotential}, Material}"><code>NeXLCore.J</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">J(ty::Type{&lt;:NeXLMeanIonizationPotential}, mat::Material)</code></pre><p>Computes the mean ionization potential for a material based on the formula in PaP1992 (Green Book)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.LinearScale-Tuple{AbstractFloat}" href="#NeXLCore.LinearScale-Tuple{AbstractFloat}"><code>NeXLCore.LinearScale</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tranforms numbers on the range [0.0, 1.0] onto a linear gray scale palette. NaNs are plotted in yellow.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Log3Band-Tuple{AbstractFloat}" href="#NeXLCore.Log3Band-Tuple{AbstractFloat}"><code>NeXLCore.Log3Band</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tranforms numbers on the range [1.0e-3, 1.0] into David Bright&#39;s Log3-band palette using a log base-10 transform. NaNs are plotted in yellow.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Log3BandC-Tuple{AbstractFloat}" href="#NeXLCore.Log3BandC-Tuple{AbstractFloat}"><code>NeXLCore.Log3BandC</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tranforms numbers on the range [1.0e-3, 1.0] into a colorblind friendly palette using a log base-10 transform. NaNs are plotted in yellow.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.LogScale-Tuple{AbstractFloat}" href="#NeXLCore.LogScale-Tuple{AbstractFloat}"><code>NeXLCore.LogScale</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Tranforms numbers on the range [1.0e-3, 1.0] onto a Log base-10 gray scale palette. NaNs are plotted in yellow.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.Rₐ-Tuple{Element}" href="#NeXLCore.Rₐ-Tuple{Element}"><code>NeXLCore.Rₐ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Rₐ(elm::Element)</code></pre><p>Classic formula for the atomic screening radius in cm</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore._mp_level1" href="#NeXLCore._mp_level1"><code>NeXLCore._mp_level1</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Parses &quot;XXX+YYY+ZZZ&quot; into add(&quot;XXX&quot;, &quot;YYY&quot;, &quot;ZZZ&quot;)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore._mp_level2-Tuple{AbstractString, AbstractString, Dict{Element, Float64}, Function}" href="#NeXLCore._mp_level2-Tuple{AbstractString, AbstractString, Dict{Element, Float64}, Function}"><code>NeXLCore._mp_level2</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parses &quot;#EXPR&quot; or &quot;#*EXPR&quot; into times(#, &quot;EXPR&quot;)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore._mp_level3-Tuple{AbstractString}" href="#NeXLCore._mp_level3-Tuple{AbstractString}"><code>NeXLCore._mp_level3</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parses &quot;something⋅#H2O&quot; or &quot;something⋅#OH&quot; or &quot;something.PO4&quot; or &quot;something&quot;,  replace &quot;X¹⁺&quot;, &quot;X²⁺&quot; and &quot;X³⁺&quot; etc with plain old &quot;X&quot;</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore._mp_level4-Tuple{AbstractString}" href="#NeXLCore._mp_level4-Tuple{AbstractString}"><code>NeXLCore._mp_level4</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Match parenthesis like &quot;pre(inner)<a href="post">n</a>&quot;</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore._mp_level5-Tuple{AbstractString}" href="#NeXLCore._mp_level5-Tuple{AbstractString}"><code>NeXLCore._mp_level5</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate simple expressions like Al2O3 or SiO2 etc.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.a-Tuple{Element, Material}" href="#NeXLCore.a-Tuple{Element, Material}"><code>NeXLCore.a</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">a(elm::Element, mat::Material)</code></pre><p>Get the atomic weight for the specified Element in the specified Material.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.a-Tuple{Element}" href="#NeXLCore.a-Tuple{Element}"><code>NeXLCore.a</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">a(elm::Element)</code></pre><p>Return the mean atomic weight of the Element in amu</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.a-Tuple{Material}" href="#NeXLCore.a-Tuple{Material}"><code>NeXLCore.a</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">a(mat::Material)</code></pre><p>Computes the mean atomic weight for a material.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.allmaterials-Tuple{Region}" href="#NeXLCore.allmaterials-Tuple{Region}"><code>NeXLCore.allmaterials</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">allmaterials(reg::Region)</code></pre><p>Generates a list of all the unique materials in a sample Region. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.analyticaltotal-Union{Tuple{Material{U, V}}, Tuple{V}, Tuple{U}} where {U&lt;:AbstractFloat, V&lt;:AbstractFloat}" href="#NeXLCore.analyticaltotal-Union{Tuple{Material{U, V}}, Tuple{V}, Tuple{U}} where {U&lt;:AbstractFloat, V&lt;:AbstractFloat}"><code>NeXLCore.analyticaltotal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">analyticaltotal(mat::Material)</code></pre><p>Return the sum of the positive mass fractions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.asnormalized-Union{Tuple{Material{U, V}}, Tuple{V}, Tuple{U}, Tuple{Material{U, V}, Any}} where {U&lt;:AbstractFloat, V&lt;:AbstractFloat}" href="#NeXLCore.asnormalized-Union{Tuple{Material{U, V}}, Tuple{V}, Tuple{U}, Tuple{Material{U, V}, Any}} where {U&lt;:AbstractFloat, V&lt;:AbstractFloat}"><code>NeXLCore.asnormalized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">asnormalized(mat::Material, n=1.0)::Material</code></pre><p>Convert the Material to a normalized Material form.  Negative mass fractions are set to zero before normalization.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.asoxide-Tuple{Element}" href="#NeXLCore.asoxide-Tuple{Element}"><code>NeXLCore.asoxide</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">asoxide(elm::Element, valences = NeXLCore.defaultValences)</code></pre><p>Compute the oxidized form of the specified element using the valences provided in <code>val</code>.  By default, <code>val = NeXLCore.defaultValences</code>, a typical set of valences.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.asoxide-Tuple{Vararg{Pair{Element, &lt;:AbstractFloat}}}" href="#NeXLCore.asoxide-Tuple{Vararg{Pair{Element, &lt;:AbstractFloat}}}"><code>NeXLCore.asoxide</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">asoxide(elms::Pair{Element, &lt;:AbstractFloat}...; valences = NeXLCore.defaultValences, atomicweights::Dict{Element,&lt;:AbstractFloat} = Dict{Element,Float64}())
asoxide(elms::Dict{Element, &lt;:AbstractFloat}...; valences = NeXLCore.defaultValences, atomicweights::Dict{Element,&lt;:AbstractFloat} = Dict{Element,Float64}())</code></pre><p>Providing the mass-fraction of the consituent elements in <code>elms</code>, compute the corresponding amounts of the oxide forms of the elements.  This can be used to answer the question: If I measure this amount of these elements, what mass fraction of the oxide-forms of each element does this correspond to?  The example below demonstrates that Albite is 68.74% SiO₂ by mass. By default, <code>val = NeXLCore.valences</code>, a typical set of valences.  See also <code>obystoichiometry(...)</code></p><p>Example:</p><pre><code class="nohighlight hljs">julia&gt; mat&quot;NaAlSi3O8&quot;
  NaAlSi3O8[Al=0.1029,Na=0.0877,Si=0.3213,O=0.4881]
julia&gt; asoxide(n&quot;Al&quot;=&gt;0.1029, n&quot;Na&quot;=&gt;0.0877, n&quot;Si&quot;=&gt;0.3213)
  Dict{Material, Float64} with 3 entries:
  SiO₂[O=0.5326,Si=0.4674]  =&gt; 0.687366
  Al₂O₃[Al=0.5293,O=0.4707] =&gt; 0.194424
  Na₂O[Na=0.7419,O=0.2581]  =&gt; 0.118216
julia&gt; sum(asoxide(n&quot;Al&quot;=&gt;0.1029, n&quot;Na&quot;=&gt;0.0877, n&quot;Si&quot;=&gt;0.3213), name=&quot;Albite&quot;)
  Albite[Al=0.1029,Na=0.0877,O=0.4881,Si=0.3213]
julia&gt; asoxide(filter(kv-&gt;kv[1]!=n&quot;O&quot;, massfraction(mat&quot;NaAlSi3O8&quot;)))
  Dict{Material, Float64} with 3 entries:
    SiO₂[O=0.5326,Si=0.4674]  =&gt; 0.687401
    Al₂O₃[Al=0.5293,O=0.4707] =&gt; 0.194418
    Na₂O[Na=0.7419,O=0.2581]  =&gt; 0.118181</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.atomicfraction-Union{Tuple{Material{U, V}}, Tuple{V}, Tuple{U}} where {U&lt;:AbstractFloat, V&lt;:AbstractFloat}" href="#NeXLCore.atomicfraction-Union{Tuple{Material{U, V}}, Tuple{V}, Tuple{U}} where {U&lt;:AbstractFloat, V&lt;:AbstractFloat}"><code>NeXLCore.atomicfraction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">atomicfraction(mat::Material{U,V})::Dict{Element,U}</code></pre><p>Return the composition in atomic fraction representation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.atomicfraction-Union{Tuple{V}, Tuple{U}, Tuple{AbstractString, Vararg{Pair{Element, U}}}} where {U&lt;:Real, V&lt;:AbstractFloat}" href="#NeXLCore.atomicfraction-Union{Tuple{V}, Tuple{U}, Tuple{AbstractString, Vararg{Pair{Element, U}}}} where {U&lt;:Real, V&lt;:AbstractFloat}"><code>NeXLCore.atomicfraction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">atomicfraction(
    name::String,
    atomfracs::Union{Dict{Element,Float64},Pair{Element,Float64}...};
    properties::properties::Dict{Symbol, Any},
    atomicweights::Dict{Element,Float64},
    density::Union{Missing, AbstractFloat}=missing,
    description::Union{Missing, AbstractString}=missing,
    pedigree::Union{Missing, AbstractString}=missing,
    conductivity::Union{Missing, Symbol}=missing, # :Conductor, :Semiconductor, :Insulator</code></pre><p>) # density, description, pedigree, conductivity</p><p>Build a Material from atomic fractions (or stoichiometries).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.atomicsubshell-Tuple{AbstractString}" href="#NeXLCore.atomicsubshell-Tuple{AbstractString}"><code>NeXLCore.atomicsubshell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">atomicsubshell(str::AbstractString)::AtomicSubShell</code></pre><p>Parse an AtomicSubShell from a string of the form &quot;Fe K&quot; or &quot;U M5&quot;.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.atomicsubshell-Tuple{Element, SubShell}" href="#NeXLCore.atomicsubshell-Tuple{Element, SubShell}"><code>NeXLCore.atomicsubshell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">atomicsubshell(elm::Element, ss::SubShell)::AtomicSubShell</code></pre><p>Construct an AtomicSubShell from from an Element and a SubShell.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.atomicsubshells-Tuple{Element}" href="#NeXLCore.atomicsubshells-Tuple{Element}"><code>NeXLCore.atomicsubshells</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> atomicsubshells(elm::Element, maxE=1.0e6)::Vector{AtomicSubShell}</code></pre><p>Returns a Vector containing all AtomicSubShell structs associated with the  specified element with less than the specified energy (in eV).</p><p>Example:</p><pre><code class="nohighlight hljs">julia&gt; atomicsubshells(n&quot;Fe&quot;,1.0e3)
8-element Array{AtomicSubShell,1}:
 Fe M3
 Fe L3
 Fe M5
 Fe L1
 Fe L2
 Fe M1
 Fe M4
 Fe M2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.atoms_per_cm³-Tuple{Material, Element}" href="#NeXLCore.atoms_per_cm³-Tuple{Material, Element}"><code>NeXLCore.atoms_per_cm³</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">atoms_per_cm³(mat::Material, elm::Element) =</code></pre><p>Number of atoms per cm³ of the specified Element in the specified Material.  The Material must define the <code>:Density</code> property.</p><pre><code class="nohighlight hljs">atoms_per_cm³(mat::Material)</code></pre><p>Total number of atoms per cm³ for all elements in mat. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.atoms_per_g-Tuple{Element}" href="#NeXLCore.atoms_per_g-Tuple{Element}"><code>NeXLCore.atoms_per_g</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">atoms_per_g(elm::Element)
atoms_per_g(mat::Material)
atoms_per_g(mat::Material, elm::Element)</code></pre><p>Compute the number of atoms of <code>elm</code> in 1 gram of <code>mat</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.bremsstrahlung-Tuple{Type{Kramers1923}, AbstractFloat, AbstractFloat, Element}" href="#NeXLCore.bremsstrahlung-Tuple{Type{Kramers1923}, AbstractFloat, AbstractFloat, Element}"><code>NeXLCore.bremsstrahlung</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bremsstrahlung(::Type{&lt;:NeXLBremsstrahlung}, e::AbstractFloat, e0::AbstractFloat, elm::Element)</code></pre><p>Calcualtes the Bremsstrahlung (continuum) at an energy <code>e</code> for an incident electron of <code>e0</code> in the element <code>elm</code>.</p><p>The supported models include:  Kramers1923, Lifshin1974, Reed1975, Smith1975, Small1987, Trincavelli1997,  Castellano2004a, Castellano2004b</p><p>Evaluating the models I find that Castellano2004a, Trincavelli1997 work well with the Riveros1993 matrix correction algorithm and the AP33Tabulation window.  Smith1975 works surprisigly well with the CitZAF matrix correction model. Other old models based on Si(Li) data tend to not do too well at lower energies.  This shouldn&#39;t surprise anyone as these models were often based on data from Be window detectors.  Castellano2004a and Trincavelli1997 were designed around the Riveros1993 matrix correction model and don&#39;t perform well using CitZAF.</p><p>My current recommendation is either Castellano2004a or Riveros1993.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.brightest-Tuple{Element, Any}" href="#NeXLCore.brightest-Tuple{Element, Any}"><code>NeXLCore.brightest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">brightest(elm::Element, shell)</code></pre><p>Return the brightest transition among the shell of transitions for the specified element.  (group=&quot;K&quot;|&quot;Ka&quot;|&quot;Kb&quot;|&quot;L&quot; etc)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.brightest-Tuple{KRatios}" href="#NeXLCore.brightest-Tuple{KRatios}"><code>NeXLCore.brightest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">brightest(krs::Union{KRatios, KRatio})</code></pre><p>Returns a new KRatios (referencing same basic data as krs) but with a single CharXRay in the <code>lines</code> field.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.buildMaterialTables-Tuple{SQLite.DB}" href="#NeXLCore.buildMaterialTables-Tuple{SQLite.DB}"><code>NeXLCore.buildMaterialTables</code></a> — <span class="docstring-category">Method</span></header><section><div><p>buildMaterialTables(db::SQLite.DB)</p><p>Build the necessary tables in a <code>SQLite</code> database to hold <code>Material</code>s.  Safe! Only creates the tables if they don&#39;t exist.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.bulk-Tuple{Material}" href="#NeXLCore.bulk-Tuple{Material}"><code>NeXLCore.bulk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bulk(mat::Material)</code></pre><p>Construct a bulk homogeneous sample at the origin.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.capacity-Tuple{SubShell}" href="#NeXLCore.capacity-Tuple{SubShell}"><code>NeXLCore.capacity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">capacity(ss::SubShell)</code></pre><p>Electron capacity for the specified sub-shell.  This is the total number of electrons that the sub-shell can hold, not the actual number a specific ground-state element may have in that sub-shell.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.chamber" href="#NeXLCore.chamber"><code>NeXLCore.chamber</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">chamber(dim=100.0)</code></pre><p>Construct a high vacuum chamber to act as the outer-most Region.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.charactericXRayAvailable-Tuple{Int64, Int64, Int64}" href="#NeXLCore.charactericXRayAvailable-Tuple{Int64, Int64, Int64}"><code>NeXLCore.charactericXRayAvailable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">characteristicXRayAvailable(z::Int, inner::Int, outer::Int)::Float64</code></pre><p>Is the weight associated with this transition greater than zero?</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.characteristic-Tuple{AbstractString}" href="#NeXLCore.characteristic-Tuple{AbstractString}"><code>NeXLCore.characteristic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">characteristic(str::AbstractString)::CharXRay</code></pre><p>Create a CharXRay structure from a string like &quot;Fe K-L3&quot; or &quot;U L3-M5&quot;.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.childmost_region-Tuple{Region, AbstractArray{Float64}}" href="#NeXLCore.childmost_region-Tuple{Region, AbstractArray{Float64}}"><code>NeXLCore.childmost_region</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">childmost_region(reg::Region, pos::Position)::Region</code></pre><p>Find the inner-most <code>Region</code> within <code>reg</code> containing the point <code>pos</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.coated_particle" href="#NeXLCore.coated_particle"><code>NeXLCore.coated_particle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coated_particle(mat::Material, radius::Float64, coating::Material, thickness::Float64, substrate::Union{Nothing,Material} = nothing)</code></pre><p>Construct a coated particle on an optional substrate.</p><p>This model is a good example of how more complex models are constructed.  Use <code>dump(..)</code> to display the structure.  You&#39;ll notice that the chamber serves as the root <code>Region</code>.  The <code>coating</code> and <code>substrate</code> are in the chamber (children of the chamber <code>Region</code>).  The <code>particle</code> is a child of the <code>coating</code> <code>Region</code> because the particle is fully enclosed by the coating.  An electron inside of the coating will enter the particle and leave the coating as soon as it enters the volume representing the particle.  The electron only appears to be within the child-most region at any point in space.  So a typical trajectory might start in the chamber, enter the coating, traverse the thickness of the coating and then enter the particle.  It may eventually leave the particle and reenter the coating, exit the coating and reenter the chamber and finally come to rest in the substrate.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.colorize" href="#NeXLCore.colorize"><code>NeXLCore.colorize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">colorize(krs::AbstractVector{&lt;:KRatios}, red::Element, green::Element, blue::Element, normalize=:All[|:Each])
colorize(krs::AbstractVector{&lt;:KRatios}, elms::AbstractVector{Element}, normalize=:All)</code></pre><p>Create RGB colorized images from up to three <code>Element</code>s.  The elements are normalized relative to all <code>KRatios</code> in <code>krs</code>. The resulting images are scaled by the factor <code>scale</code> to allow visualization of trace elements.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.colorize-Tuple{Region}" href="#NeXLCore.colorize-Tuple{Region}"><code>NeXLCore.colorize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">colorize(reg::Region)::Dict{Material, Color}</code></pre><p>Generate a <code>Dict{Material, Color}</code> for all the <code>Materials</code> in the specified <code>Region</code>. Designed for distinctive but not necessarily attractive colors.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.compare-Tuple{Material, Material}" href="#NeXLCore.compare-Tuple{Material, Material}"><code>NeXLCore.compare</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compare(unk::Material, known::Material)::DataFrame</code></pre><p>Compare two compositions in a DataFrame.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.compareMACs-Tuple{Element}" href="#NeXLCore.compareMACs-Tuple{Element}"><code>NeXLCore.compareMACs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compareMACs(elm::Element; palette=NeXLPalette)</code></pre><p>Plot a comparison of the FFAST and Heinrich MAC tabulations for the specified Element.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.compositionlibrary-Tuple{}" href="#NeXLCore.compositionlibrary-Tuple{}"><code>NeXLCore.compositionlibrary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compositionlibrary()::Dict{String, Material}</code></pre><p>Load the internal compositon library.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.comptonAngular-Tuple{Any, Any}" href="#NeXLCore.comptonAngular-Tuple{Any, Any}"><code>NeXLCore.comptonAngular</code></a> — <span class="docstring-category">Method</span></header><section><div><p>comptonAngular(θ, E)</p><p>The angular distribution function of Compton scattered X-rays of incident energy <code>E</code> scattered to an angle <code>θ</code>.</p><p>Based on the Klein-Nishina formula for Compton scattering. It has been normalized so that the integral over dΩ = 2π⋅sin(θ) dθ equals one.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.comptonDifferential-Tuple{Any, Any}" href="#NeXLCore.comptonDifferential-Tuple{Any, Any}"><code>NeXLCore.comptonDifferential</code></a> — <span class="docstring-category">Method</span></header><section><div><p>comptonDifferential(θ, E)</p><p>Differential crosssection dσ/dΩ = dσ/(sin(θ) dθ dϕ) for Compton scattering in cm².</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.comptonEnergy-Tuple{Any, Any}" href="#NeXLCore.comptonEnergy-Tuple{Any, Any}"><code>NeXLCore.comptonEnergy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>comptonEnergy(θ, E)</p><p>The energy of the scattered X-ray resulting from a Compton event with an incident X-ray energy of <code>E</code> eV at a scatter angle of <code>θ</code> radians.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.comptonShift-Tuple{Any, Any}" href="#NeXLCore.comptonShift-Tuple{Any, Any}"><code>NeXLCore.comptonShift</code></a> — <span class="docstring-category">Method</span></header><section><div><p>comptonShift(θ, E)</p><p>The fractional energy of the scattered X-ray resulting from a Compton event with an incident X-ray energy of <code>E</code> eV at a scatter angle of <code>θ</code> radians.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.compute_tilt-Tuple{Vector, Vector, Vector}" href="#NeXLCore.compute_tilt-Tuple{Vector, Vector, Vector}"><code>NeXLCore.compute_tilt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_tilt(v1::Vector, v2::Vector, v3::Vector)</code></pre><p>Compute the tilt and angle of tilt of the sample where <code>v1</code>, <code>v2</code> and <code>v3</code> are three points forming a triangle with each focused on the surface of the sample.  Assumes a right-handed  coordinate system which may/may not match your stage.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.configuration-Tuple{Element}" href="#NeXLCore.configuration-Tuple{Element}"><code>NeXLCore.configuration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">configuration(elm::Element)</code></pre><p>The configuration of the shell occupancy in a specific ground-state element.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.dEds" href="#NeXLCore.dEds"><code>NeXLCore.dEds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dEds(::Type{&lt;:BetheEnergyLoss}, e::Float64, elm::Element, ρ::Float64; mip::Type{&lt;:NeXLMeanIonizationPotential}=Berger1982)
dEds(::Type{&lt;:BetheEnergyLoss}, e::Float64, mat::Material, inclDensity=true; mip::Type{&lt;:NeXLMeanIonizationPotential}=Berger1982)</code></pre><p>Calculate the loss per unit path length for an electron in the specified element and density.  The results in energy loss in eV/Å.  Implemented by <code>Type{Bethe}</code> and <code>Type{JoyLuo}</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.delete-Tuple{Material, Element}" href="#NeXLCore.delete-Tuple{Material, Element}"><code>NeXLCore.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delete(mat::Material, elm::Element)::Material
delete(mat::Material, elm::AbstractVector{Element})::Material</code></pre><p>Constructs a new Material from <code>mat</code> with <code>elm</code> removed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.density-Tuple{Element}" href="#NeXLCore.density-Tuple{Element}"><code>NeXLCore.density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">density(elm::Element)</code></pre><p>Return the nominal density for the element in g/cm³.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.density-Tuple{Material}" href="#NeXLCore.density-Tuple{Material}"><code>NeXLCore.density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">density(mat::Material)</code></pre><p>Return the density in g/cm³ (Might be &#39;missing&#39;)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.description-Tuple{Material}" href="#NeXLCore.description-Tuple{Material}"><code>NeXLCore.description</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">description(mat::Materail)</code></pre><p>The :Description property.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.eachelement" href="#NeXLCore.eachelement"><code>NeXLCore.eachelement</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eachelement()</code></pre><p>Return the range of atomic numbers for which there is a complete set of energy, weight, MAC, ... data</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.eachsubshell-Tuple{Element}" href="#NeXLCore.eachsubshell-Tuple{Element}"><code>NeXLCore.eachsubshell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachsubshell(elm::Element)</code></pre><p>Iterates over each sub-shell that is present in an element.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.edgeenergy-Tuple{CharXRay}" href="#NeXLCore.edgeenergy-Tuple{CharXRay}"><code>NeXLCore.edgeenergy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edgeenergy(cxr::CharXRay)</code></pre><p>Returns the energy associated with the inner shell of this characteristic X-ray (eV).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.elasticfraction-Tuple{Element, Material, Float64}" href="#NeXLCore.elasticfraction-Tuple{Element, Material, Float64}"><code>NeXLCore.elasticfraction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">elasticfraction(elm::Element, mat::Material, e0::Float64)::Float64</code></pre><p>Computes the fraction of the total scattering cross-section associated with <code>elm</code> in <code>mat</code> at beam energy <code>e0</code>.</p><p>@incollection{armstrong1991quantitative,   title={Quantitative elemental analysis of individual microparticles with electron beam instruments},   author={Armstrong, John T},   booktitle={Electron probe quantitation},   pages={261–315},   year={1991},   publisher={Springer} }</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.electronfraction-Tuple{Element, Material}" href="#NeXLCore.electronfraction-Tuple{Element, Material}"><code>NeXLCore.electronfraction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">electronfraction(elm::Element, mat::Material)::Float64</code></pre><p>The electron fraction as defined in:</p><p>@article{donovan2003compositional,   title={Compositional averaging of backscatter intensities in compounds},   author={Donovan, John J and Pingitore, Nicholas E and Westphal, Andrew},   journal={Microscopy and Microanalysis},   volume={9},   number={3},   pages={202–215},   year={2003},   publisher={Cambridge University Press} }</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.electrons_per_second-Tuple{Unitful.Quantity}" href="#NeXLCore.electrons_per_second-Tuple{Unitful.Quantity}"><code>NeXLCore.electrons_per_second</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Electrons per second per nA of current.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.element-Tuple{AbstractString}" href="#NeXLCore.element-Tuple{AbstractString}"><code>NeXLCore.element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">element(str::AbstractString)</code></pre><p>Parses a string to determine if the string represents an Element by atomic number, symbol or name.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.element-Tuple{AtomicSubShell}" href="#NeXLCore.element-Tuple{AtomicSubShell}"><code>NeXLCore.element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> element(ass::AtomicSubShell)</code></pre><p>The Element associated with the specified sub-shell.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.element-Tuple{CharXRay}" href="#NeXLCore.element-Tuple{CharXRay}"><code>NeXLCore.element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">element(cxr::CharXRay)</code></pre><p>Return the element for this CharXRay.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.element-Tuple{Integer}" href="#NeXLCore.element-Tuple{Integer}"><code>NeXLCore.element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">element(z::Int)::PeriodicTable.Element</code></pre><p>Covert an atomic number into a PeriodicTable.Element</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.elms-Tuple{Material}" href="#NeXLCore.elms-Tuple{Material}"><code>NeXLCore.elms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">elms(mat::Material)</code></pre><p>The elements with mass fraction ≠ 0.0 in <code>mat</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.elms-Tuple{Vector{&lt;:NeXLCore.KRatioBase}}" href="#NeXLCore.elms-Tuple{Vector{&lt;:NeXLCore.KRatioBase}}"><code>NeXLCore.elms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">elms(krs::Vector{KRatio})::Set{Element}</code></pre><p>Return a set containing the elements present in krs.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.energy-Tuple{AtomicSubShell, Type{DefaultAlgorithm}}" href="#NeXLCore.energy-Tuple{AtomicSubShell, Type{DefaultAlgorithm}}"><code>NeXLCore.energy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> energy(ass::AtomicSubShell)
 energy(elm::Element, ss::SubShell)</code></pre><p>The edge energy in eV for the specified AtomicSubShell</p><p>Example:</p><pre><code class="nohighlight hljs">julia&gt; energy(n&quot;Fe L3&quot;)
708.0999999999999
julia&gt; energy(n&quot;Fe&quot;, n&quot;L3&quot;)
708.0999999999999

energy(elm::Element, tr::Transition)::Float64
energy(cxr::CharXRay)</code></pre><p>The characteristic X-ray energy for the specified element / transition or characteristic X-ray.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.exists-Tuple{SubShell, SubShell}" href="#NeXLCore.exists-Tuple{SubShell, SubShell}"><code>NeXLCore.exists</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exists(inner::SubShell, outer::SubShell)::Bool</code></pre><p>Does a transition exist in our database for this pair of shells?</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.fluorescenceyield-Tuple{AtomicSubShell, Type{Burhop1965}}" href="#NeXLCore.fluorescenceyield-Tuple{AtomicSubShell, Type{Burhop1965}}"><code>NeXLCore.fluorescenceyield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fluorescenceyield(ass::AtomicSubShell, ::Type{Burhop1965})</code></pre><p>An approximate expression for the K-shell fluorescence yield due to E.H.S Burhop, J. Phys. Radium, 16, 625 (1965). Seems reasonable.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.fluorescenceyield-Tuple{AtomicSubShell, Type{Kahoul2012}}" href="#NeXLCore.fluorescenceyield-Tuple{AtomicSubShell, Type{Kahoul2012}}"><code>NeXLCore.fluorescenceyield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Kahoul 2012 expression for the K-shell fluorescence yield</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.fluorescenceyield-Tuple{AtomicSubShell, Type{Sogut2002}}" href="#NeXLCore.fluorescenceyield-Tuple{AtomicSubShell, Type{Sogut2002}}"><code>NeXLCore.fluorescenceyield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fluorescenceyield(ass::AtomicSubShell, ::Type{Sogut2002})</code></pre><p>An alternative for M-line yields.  Not alway reasonable.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.fluorescenceyield-Tuple{CharXRay}" href="#NeXLCore.fluorescenceyield-Tuple{CharXRay}"><code>NeXLCore.fluorescenceyield</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Represents the fractional number of X-rays emitted following the ionization of the sub-shell <code>ionized</code> via the characteristic X-ray <code>z inner-outer</code>.  Due to cascades, <code>inner</code> does not necessarily equal <code>ionized</code>. The <code>ionized</code> subshell may transition to a valency in <code>inner</code> via a combination of Auger, fluorescence or Koster-Kronig transitions.  The various different forms make assumptions about the relationship between <code>ionized</code> and <code>inner</code>, and about <code>outer</code>.</p><pre><code class="nohighlight hljs">fluorescenceyield(ass::AtomicSubShell)::Float64</code></pre><p>The fraction of relaxations from the specified shell that relax via any radiative transition. (<code>inner</code>==<code>ionized</code>)</p><pre><code class="nohighlight hljs">fluorescenceyield(cxr::CharXRay)</code></pre><p>The fraction of ionizations of <code>inner(cxr)</code> that relax via the one path <code>cxr</code>. <code>ionized==inner</code> &amp;&amp; outer(cxr)</p><pre><code class="nohighlight hljs">fluorescenceyield(ash::AtomicSubShell, cxr::CharXRay)::Float64</code></pre><p>The fractional number of <code>cxr</code> X-rays emitted (on average) for each ionization of <code>ash</code>.  This makes no  assumptions about <code>inner</code>, <code>outer</code> and <code>ionized</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.fractionaluncertainty-Tuple{Type{NeXLCore.MonatomicGas}, Integer, Any}" href="#NeXLCore.fractionaluncertainty-Tuple{Type{NeXLCore.MonatomicGas}, Integer, Any}"><code>NeXLCore.fractionaluncertainty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fractionaluncertainty(::Type{MonatomicGas}, z::Integer, energy)</code></pre><p>Determines from the element and energy, the approximate range of fractional uncertainties to associate with the total and photoelectric components of the mass attenuation coefficients for monatomic gas samples. Based on <a href="https://physics.nist.gov/PhysRefData/FFast/Text2000/sec06.html#tab2">this table</a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.fractionaluncertainty-Tuple{Type{NeXLCore.SolidLiquid}, Integer, Any}" href="#NeXLCore.fractionaluncertainty-Tuple{Type{NeXLCore.SolidLiquid}, Integer, Any}"><code>NeXLCore.fractionaluncertainty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fractionaluncertainty(::Type{SolidLiquid}, z::Integer, energy)</code></pre><p>Determines from the element and energy, the approximate range of fractional uncertainties to associate with the total and photoelectric components of the mass attenuation coefficients for solids and liquids. Based on <a href="https://physics.nist.gov/PhysRefData/FFast/Text2000/sec06.html#tab2">this table</a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.gun-Union{Tuple{T}, Tuple{Type{T}, Float64}, Tuple{Type{T}, Float64, Float64}, Tuple{Type{T}, Float64, Float64, GeometryBasics.Point3{Float64}}, Tuple{Type{T}, Float64, Float64, GeometryBasics.Point3{Float64}, Any}} where T&lt;:Particle" href="#NeXLCore.gun-Union{Tuple{T}, Tuple{Type{T}, Float64}, Tuple{Type{T}, Float64, Float64}, Tuple{Type{T}, Float64, Float64, GeometryBasics.Point3{Float64}}, Tuple{Type{T}, Float64, Float64, GeometryBasics.Point3{Float64}, Any}} where T&lt;:Particle"><code>NeXLCore.gun</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gun(::Type{T}, energy::Float64, width::Float64=1.0e-7, initial::Position=Position(0.0,0.0,-10.0), direction=Position(0.0,0.0,1.0)::T where {T &lt;: Particle}</code></pre><p>A helper to construct the initial <code>Particle</code> in a randomized Gaussian distribution.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.has-Tuple{Element, SubShell}" href="#NeXLCore.has-Tuple{Element, SubShell}"><code>NeXLCore.has</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has(elm::Element, s::SubShell) =</code></pre><p>Is the specified sub-shell occupied by one or more electrons in a ground-state atom of the specified element?</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.has-Tuple{Element, Transition}" href="#NeXLCore.has-Tuple{Element, Transition}"><code>NeXLCore.has</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has(elm::Element, tr::Transition)::Bool</code></pre><p>Is the specified Transition available for the specified element?</p><p>Example:</p><pre><code class="nohighlight hljs">@assert has(n&quot;Fe L3-M5)
@assert !has(n&quot;Fe N7-O9)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.hasminrequired-Tuple{Type, Dict{Symbol, Any}}" href="#NeXLCore.hasminrequired-Tuple{Type, Dict{Symbol, Any}}"><code>NeXLCore.hasminrequired</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hasminrequired(ty::Type, item::Union{Spectrum,Dict{Symbol,Any}})</code></pre><p>Does this spectrum have the minimal set of required properties?</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.image2stage-Tuple{Type{DefaultStageMapping}, Dict, Dict, Float64}" href="#NeXLCore.image2stage-Tuple{Type{DefaultStageMapping}, Dict, Dict, Float64}"><code>NeXLCore.image2stage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">image2stage(::Type{DefaultStageMapping}, stage_coord::Dict{Symbol,Any}, img_coord::Dict{Symbol,Any}, theta::Float64)</code></pre><p>Given the stage coordinate at the center of the image <code>stage_coord</code>, the pixel coordinate of interest (in the same units as <code>stage_coord</code>) and the image rotation <code>theta</code>, compute the stage coordinate that would bring the pixel into the center of the image. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.inner-Tuple{CharXRay}" href="#NeXLCore.inner-Tuple{CharXRay}"><code>NeXLCore.inner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inner(cxr::CharXRay)</code></pre><p>Return the inner AtomicSubShell associated with the specified CharXRay.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.ionizationcrosssection-Tuple{Int64, Int64, AbstractFloat, Type{Bote2009}}" href="#NeXLCore.ionizationcrosssection-Tuple{Int64, Int64, AbstractFloat, Type{Bote2009}}"><code>NeXLCore.ionizationcrosssection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ionizationcrosssection(z::Int, shell::Int, energy::AbstractFloat, ::Type{Bote2009})
ionizationcrosssection(ass::AtomicSubShell, energy::AbstractFloat, ty::Type{&lt;:NeXLAlgorithm}=Bote2009)</code></pre><p>Computes the absolute ionization crosssection (in cm²/e⁻) for the specified AtomicSubShell and electon energy (in eV).</p><p>Example:</p><pre><code class="nohighlight hljs">julia&gt; (/)(map(e-&gt;NeXLCore.ionizationcrosssection(n&quot;Fe K&quot;,e),[10.0e3,20.0e3])...)
0.5672910174711278</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.ispure-Tuple{Material}" href="#NeXLCore.ispure-Tuple{Material}"><code>NeXLCore.ispure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ispure(mat::Material)</code></pre><p>Does <code>mat</code> represent a single element.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.isstandard-Tuple{KRatio}" href="#NeXLCore.isstandard-Tuple{KRatio}"><code>NeXLCore.isstandard</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isstandard(kr::KRatio)::Boolean</code></pre><p>Does this k-ratio have all the necessary basic properties required for use as a standard  (:TakeOffAngle, and :BeamEnergy for both <code>stdProps</code> and <code>unkProps</code> and :Composition for  <code>unkProps</code>.)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.j-Tuple{SubShell}" href="#NeXLCore.j-Tuple{SubShell}"><code>NeXLCore.j</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> j(ss::SubShell)</code></pre><p>Total angular momentum quantum number</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.jumpratio-Tuple{AtomicSubShell, Type{Poehn1985}}" href="#NeXLCore.jumpratio-Tuple{AtomicSubShell, Type{Poehn1985}}"><code>NeXLCore.jumpratio</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jumpratio(ashell::AtomicSubShell, ::Type{Poehn1985})</code></pre><p>An implement of jump ratios attributed to</p><ul><li>Poehn, Wernisch, Hanke (1985) X-ray Spectrom 14(3):120, 1985</li></ul><p>Compares reasonably over available range.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.klinewidths-Tuple{Element}" href="#NeXLCore.klinewidths-Tuple{Element}"><code>NeXLCore.klinewidths</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">klinewidths(elm::Element)</code></pre><p>Linewidth of the K shell according to Bambynek&#39;1974 errata to Bambynek 1972. Shown to be reliable for Z&gt;36 or so.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.kₑ-Tuple{Unitful.Quantity}" href="#NeXLCore.kₑ-Tuple{Unitful.Quantity}"><code>NeXLCore.kₑ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kₑ(E::Float64)</code></pre><p>Electron wavenumber (inverse wavelength) in rad⋅cm⁻¹.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.l-Tuple{SubShell}" href="#NeXLCore.l-Tuple{SubShell}"><code>NeXLCore.l</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">l(ss::SubShell)</code></pre><p>Orbital angular momentum quantum number</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.labeled-Tuple{Material}" href="#NeXLCore.labeled-Tuple{Material}"><code>NeXLCore.labeled</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">labeled(mat::Material)</code></pre><p>Transform the mass fraction representation of a material into a Dict{MassFractionLabel,AbstractFloat}</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.listcustommacs-Tuple{CharXRay}" href="#NeXLCore.listcustommacs-Tuple{CharXRay}"><code>NeXLCore.listcustommacs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">listcustommacs(cxr::CharXRay)</code></pre><p>Generated a list of available custom MACs for <code>cxr</code> in various elements.</p><pre><code class="nohighlight hljs">listcustommacs(elms::Set{Element}|AbstractVector{Element}|Element...|Material)</code></pre><p>Generate a list of available custom MACS for elements and X-rays both produced and absorbed by these elements.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.loadcustommac!-Tuple{Element, CharXRay, AbstractString}" href="#NeXLCore.loadcustommac!-Tuple{Element, CharXRay, AbstractString}"><code>NeXLCore.loadcustommac!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loadcustommac!(elm::Element, cxr::CharXRay, source::AbstractString)</code></pre><p>Load the custom mass absorption coefficient associated with the specified <code>CharXRay</code> in the <code>Element</code> from the source. Use <code>listcustommacs(cxr)</code> to explore available MACs.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.loadcustommacs!-Tuple{AbstractString, AbstractArray{Element}}" href="#NeXLCore.loadcustommacs!-Tuple{AbstractString, AbstractArray{Element}}"><code>NeXLCore.loadcustommacs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loadcustommacs!(source::AbstractString, elms::AbstractArray{Element})
loadcustommacs!(source::AbstractString, elm::Element)</code></pre><p>Load custom macs from the database associated with the specified source.</p><p>Sources include &quot;Henke1974&quot;, &quot;Henke1982&quot;, &quot;Bastin1989&quot;, &quot;Henke1993&quot;, &quot;Bastin1997&quot;, &quot;Ruste1979&quot;, &quot;Kohlhaas1970&quot;, &quot;Weisweiler1975&quot;,  &quot;Bastin1990&quot;, &quot;Bastin1988&quot;, &quot;Poml2020&quot;, &quot;Ruste1975&quot;, &quot;Henke1982&quot;, &quot;Farthing1990&quot;, &quot;Sabbatucci2016&quot;</p><p>Use <code>listcustommacs(cxr)</code> to explore available MACs.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.loadlegend-Tuple{String}" href="#NeXLCore.loadlegend-Tuple{String}"><code>NeXLCore.loadlegend</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Loads a legend image from the package source directory. Some legends include &quot;LinearScale.png&quot;, &quot;LogScale.png&quot;, &quot;Log3BandBright.png&quot;, &quot;Log3BandColorblind.png&quot;.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.loadsmithsoniandata-Tuple{}" href="#NeXLCore.loadsmithsoniandata-Tuple{}"><code>NeXLCore.loadsmithsoniandata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loadsmithsoniandata(; clean=false)</code></pre><p>Load compositional data associated with the Smithsonian Microbeam Standards data set as a DataFrame. Setting clean=true will replace &quot;&lt;0.XXX&quot; with 0.0, replace &quot;missing&quot; with 0.0 and parse string values as Float64.   The data source is https://naturalhistory.si.edu/research/mineral-sciences/collections-overview/reference-materials/smithsonian-microbeam-standards</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.mac" href="#NeXLCore.mac"><code>NeXLCore.mac</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mac(mat::Material, xray::Union{Float64,CharXRay}, alg::Type{&lt;:NeXLAlgorithm}=DefaultAlgorithm)::Float64</code></pre><p>Compute the material MAC using the standard mass fraction weighted formula.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.mac-Tuple{Element, Float64, Type{DTSA}}" href="#NeXLCore.mac-Tuple{Element, Float64, Type{DTSA}}"><code>NeXLCore.mac</code></a> — <span class="docstring-category">Method</span></header><section><div><p>mac(zz::Int, ev::Float64, ::Type{DTSA})::Float64</p><p>Calculate the elemental MAC using Heinrich&#39;s IXCOM 11 formula as implemented by Myklebust in DTSA.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.mac-Tuple{Element, Float64, Type{DefaultAlgorithm}}" href="#NeXLCore.mac-Tuple{Element, Float64, Type{DefaultAlgorithm}}"><code>NeXLCore.mac</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mac(elm::Element, energy::Float64)::Float64
mac(elm::Element, cxr::CharXRay)::Float64</code></pre><p>The mass absorption coefficient for an X-ray of the specified energy (eV) or characteristic X-ray line in the specified element.  In cm²/g.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.macU" href="#NeXLCore.macU"><code>NeXLCore.macU</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">macU(elm::Element, energy::Float64)
macU(elm::Element, cxr::CharXRay)::UncertainValue</code></pre><p>The mass absorption coefficient (with uncertainty estimate) for an X-ray of the specified energy (eV)  or characteristix X-ray line in the specified element.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.massfraction-Tuple{Material}" href="#NeXLCore.massfraction-Tuple{Material}"><code>NeXLCore.massfraction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">massfraction(mat::Material)::Dict{Element, AbstractFloat}</code></pre><p>The mass fraction as a Dict{Element, AbstractFloat}</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.massthickness-Tuple{Film}" href="#NeXLCore.massthickness-Tuple{Film}"><code>NeXLCore.massthickness</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">massthickness(flm::Film)</code></pre><p>The mass-thickness of the film in g/cm².</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.matches-Tuple{Union{KRatio, KRatios}, KRatio}" href="#NeXLCore.matches-Tuple{Union{KRatio, KRatios}, KRatio}"><code>NeXLCore.matches</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matches(kr::Union{KRatio, KRatios}, std::Standard)::Bool</code></pre><p>Is <code>std</code> a match for <code>kr</code>? (Same element, same standard, same lines, same :BeamEnergy &amp; :TakeOffAngle )</p><p>stdProps[:Composition] items match if 1) are Materials with almost the same mass-fractions; 2) they are equivalent AbstractString values.  The later is for </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.material-Union{Tuple{U}, Tuple{AbstractString, Dict{Element, U}}} where U&lt;:AbstractFloat" href="#NeXLCore.material-Union{Tuple{U}, Tuple{AbstractString, Dict{Element, U}}} where U&lt;:AbstractFloat"><code>NeXLCore.material</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">material(
    name::AbstractString,
    massfrac::Dict{Element,U};
    properties::Union{Missing,Dict{Symbol,Any}} = missing,
    atomicweights::Union{Missing, Dict{Element,Float64}} = missing,
    density::Union{Missing,AbstractFloat} = missing,
    description::Union{Missing,AbstractString} = missing,
    pedigree::Union{Missing,AbstractString} = missing,
    conductivity::Union{Missing,Symbol} = missing, # :Conductor, :Semiconductor, :Insulator
)
material(
    name::AbstractString,
    massfrac::Dict{Element,&lt;:AbstractFloat};
    properties::Dict{Symbol,Any}=Dict{Symbol,Any)(),
    atomicweights::Dict{Element, &lt;:AbstractFloat}=Dict{Element,Float64}(),
    density::Union{Missing, AbstractFloat}=missing,
    description::Union{Missing, AbstractString}=missing,
    pedigree::Union{Missing, AbstractString}=missing,
    conductivity::Union{Missing, Symbol}=missing, # :Conductor, :Semiconductor, :Insulator
)</code></pre><p>Constuct a material from mass fraction pairs.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.materiallabels-Tuple{Type{&lt;:MaterialLabel}, String, Union{LabeledValues, UncertainValues}}" href="#NeXLCore.materiallabels-Tuple{Type{&lt;:MaterialLabel}, String, Union{LabeledValues, UncertainValues}}"><code>NeXLCore.materiallabels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">materiallabels(ty::Type{&lt;:MaterialLabel}, material::String, uvs::Union{LabeledValues,UncertainValues})</code></pre><p>Useful for extracting the MaterialLabel[s] associated with a single material.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.mf2comp-Tuple{String, UncertainValues}" href="#NeXLCore.mf2comp-Tuple{String, UncertainValues}"><code>NeXLCore.mf2comp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mf2comp(material::String, mfs::UncertainValues)::UncertainValues
mf2comp(mat::Material)::UncertainValues</code></pre><p>Converts a material composition expressed in the <code>mfs</code> UncertainValues struct into a handful of common representations including normalized mass fraction, atomic fraction, mean Z and mean atomic number.  The second form converts a Material into UncertainValues form.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.minproperties-Tuple{Type{Any}}" href="#NeXLCore.minproperties-Tuple{Type{Any}}"><code>NeXLCore.minproperties</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minrequired(::Type{XXX})</code></pre><p>Returns the minimum required properties.  Other classes implement this to check whether a Spectrum or Dict has all the necessary properties for the specified algorithm or data structure.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.mixture-Tuple{String, Vararg{Pair{Material, UncertainValue}}}" href="#NeXLCore.mixture-Tuple{String, Vararg{Pair{Material, UncertainValue}}}"><code>NeXLCore.mixture</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mixture(mat::String, mix::Pair{UncertainValues,UncertainValue}...)::UncertainValues
mixture(mat::String, mix::Pair{Material, UncertainValue}...)::UncertainValues</code></pre><p>Converts a mixture of materials into a material. In the first case, the input materials are in UncertainValues representation. In the second case, the Material instances are converted to the UncertainValues representation. In each case, the first item in the Pair represents a material and the second the mass fraction of that material in the mixture.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.name" href="#NeXLCore.name"><code>NeXLCore.name</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">name(cxrs::AbstractVector{CharXRay}, byfamily=false)</code></pre><p>An abbeviated name for a collection of CharXRay.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.name-Tuple{Element}" href="#NeXLCore.name-Tuple{Element}"><code>NeXLCore.name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">name(elm::Element)</code></pre><p>Return the name like &quot;Hydrogen&quot;, &quot;Helium&quot;,... for the Element.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.name-Tuple{Material}" href="#NeXLCore.name-Tuple{Material}"><code>NeXLCore.name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">name(mat::Material)</code></pre><p>Return a human friendly short name for the Material.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.nonneg-Union{Tuple{V}, Tuple{U}, Tuple{Material{U, V}, Element}} where {U&lt;:AbstractFloat, V&lt;:AbstractFloat}" href="#NeXLCore.nonneg-Union{Tuple{V}, Tuple{U}, Tuple{Material{U, V}, Element}} where {U&lt;:AbstractFloat, V&lt;:AbstractFloat}"><code>NeXLCore.nonneg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nonneg(mat::Material{U,V}, elm::Element)::U where {U&lt;:AbstractFloat,V&lt;:AbstractFloat}
nonneg(mat::Material{UncertainValue,V}, elm::Element)::Float64 where {V&lt;:AbstractFloat}
nonneg(mat::Material)::Material</code></pre><p>Returns the mass fraction of <code>elm::Element</code> truncated to be non-negative.  Negative values are returned as 0.0. Positive values are returned as is.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.normalized-Union{Tuple{V}, Tuple{Material{UncertainValue, V}, Element}, Tuple{Material{UncertainValue, V}, Element, Any}} where V&lt;:AbstractFloat" href="#NeXLCore.normalized-Union{Tuple{V}, Tuple{Material{UncertainValue, V}, Element}, Tuple{Material{UncertainValue, V}, Element, Any}} where V&lt;:AbstractFloat"><code>NeXLCore.normalized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalized(mat::Material{U,V}, elm::Element, n=1.0)</code></pre><p>Returns the mass fraction of &#39;elm::Element&#39; such that the returned value is non-negative and the sum of all values is unity.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.normalizedmassfraction-Union{Tuple{Material{U, V}}, Tuple{V}, Tuple{U}, Tuple{Material{U, V}, Any}} where {U&lt;:AbstractFloat, V&lt;:AbstractFloat}" href="#NeXLCore.normalizedmassfraction-Union{Tuple{Material{U, V}}, Tuple{V}, Tuple{U}, Tuple{Material{U, V}, Any}} where {U&lt;:AbstractFloat, V&lt;:AbstractFloat}"><code>NeXLCore.normalizedmassfraction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalizedmassfraction(mat::Material)::Dict{Element, AbstractFloat}</code></pre><p>Return the normalized mass fraction as a Dict{Element, AbstractFloat}.  Negative values are set to zero.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.normalizek-Tuple{AbstractVector{&lt;:KRatios}}" href="#NeXLCore.normalizek-Tuple{AbstractVector{&lt;:KRatios}}"><code>NeXLCore.normalizek</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalizek(krs::AbstractVector{&lt;:KRatios}; norm::Float32=1.0f)::Vector{KRatios}
normalizek(krs::AbstractVector{KRatio}; norm::Float32=1.0f)::Vector{KRatio}</code></pre><p>Computes the pixel-by-pixel normalized k-ratio for each point in the KRatios data array. <code>norm</code> specifies normalization constants other than 1.0.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.obystoichiometry-Tuple{Dict{Element, &lt;:AbstractFloat}}" href="#NeXLCore.obystoichiometry-Tuple{Dict{Element, &lt;:AbstractFloat}}"><code>NeXLCore.obystoichiometry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">obystoichiometry(elms::Pair{Element, &lt;:AbstractFloat}..., valences = NeXLCore.defaultValences)
obystoichiometry(elms::Dict{Element, &lt;:AbstractFloat}; valences = NeXLCore.defaultValences)</code></pre><p>Compute O-by-stoichiometry from the provided mass fractions of elements.</p><p>Example:</p><pre><code class="nohighlight hljs">obystoichiometry(n&quot;Mg&quot;=&gt;0.1099, n&quot;Al&quot;=&gt;0.0443, n&quot;Si&quot;=&gt;0.1941, n&quot;Ca&quot;=&gt;0.1034, n&quot;Fe&quot;=&gt;0.0756)
0.39582340257233467</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.outer-Tuple{CharXRay}" href="#NeXLCore.outer-Tuple{CharXRay}"><code>NeXLCore.outer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outer(cxr::CharXRay)</code></pre><p>Return the outer AtomicSubShell associated with the specified CharXRay.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.parsedsmithsoniandata-Tuple{}" href="#NeXLCore.parsedsmithsoniandata-Tuple{}"><code>NeXLCore.parsedsmithsoniandata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parsedsmithsoniandata()::Dict{String, Material}</code></pre><p>Converts the data from loadsmithsoniandata() into Material representation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.parsex-Tuple{AbstractString}" href="#NeXLCore.parsex-Tuple{AbstractString}"><code>NeXLCore.parsex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parsex(str::AbstractString)::Union{Element, SubShell, AtomicSubShell, Transition, CharXRay}</code></pre><p>Implements compile time parsing of strings to produce Element, SubShell, AtomicSubShell, Transition or CharXRay objects. The only oddity is that to get SubShell(&quot;K&quot;) you must enter n&quot;K1&quot; to differentiate the sub-shell from potassium. <code>parsex(...)</code> provides the implementation for <code>n&quot;...&quot;</code>.</p><p>Examples:</p><ul><li>n&quot;Fe&quot; =&gt; Element </li><li>n&quot;L3&quot; =&gt; SubShell</li><li>n&quot;K&quot; =&gt; Element</li><li>n&quot;K1&quot; =&gt; SubShell (&quot;K&quot; would be the element potassium)</li><li>n&quot;Fe K&quot; =&gt; AtomicSubShell (&quot;K&quot; not ambiguous here...)</li><li>n&quot;Fe L3&quot; =&gt; AtomicSubShell</li><li>n&quot;L3-M5&quot; =&gt; Transition</li><li>n&quot;Fe L3-M5&quot; =&gt; CharXRay.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.particle" href="#NeXLCore.particle"><code>NeXLCore.particle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">particle(mat::Material, radius::Float64, substrate::Union{Nothing,Material} = nothing)</code></pre><p>Construct a spherical particle at the origin with an optional bulk substrate.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.pathlength-Tuple{Particle}" href="#NeXLCore.pathlength-Tuple{Particle}"><code>NeXLCore.pathlength</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pathlength(el::Particle)</code></pre><p>Length of the line segment represented by <code>el</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.pedigree-Tuple{Material}" href="#NeXLCore.pedigree-Tuple{Material}"><code>NeXLCore.pedigree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pedigree(mat::Material)</code></pre><p>The :Pedigree property.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.pure-Tuple{Element}" href="#NeXLCore.pure-Tuple{Element}"><code>NeXLCore.pure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> material(str::String, density::Float64)
 nargs...
pure(elm::Element)</code></pre><p>Construct a Material to represent a pure element.</p><p>Example:</p><pre><code class="nohighlight hljs">&gt; pure(n&quot;Fe&quot;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.random_point_inside-Tuple{Any}" href="#NeXLCore.random_point_inside-Tuple{Any}"><code>NeXLCore.random_point_inside</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_point_inside(shape)</code></pre><p>Generate a randomized point that is guaranteed to be in the interior of the shape.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.relativeionizationcrosssection-Tuple{AtomicSubShell, AbstractFloat, Type{NeXLCore.Pouchou1991}}" href="#NeXLCore.relativeionizationcrosssection-Tuple{AtomicSubShell, AbstractFloat, Type{NeXLCore.Pouchou1991}}"><code>NeXLCore.relativeionizationcrosssection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relativeionizationcrosssection(z::Int, ss::Int, ev::AbstractFloat)
relativeionizationcrosssection(ass::AtomicSubShell, ev::AbstractFloat, ::Type{Pouchou1991})</code></pre><p>An approximate expression based of Pouchou and Pouchoir&#39;s 1991 (Green Book) expression for the ionization crosssection plus an additional factor for sub-shell occupancy.</p><p>Example:</p><pre><code class="nohighlight hljs">&gt; (/)(map(e-&gt;NeXLCore.relativeionizationcrosssection(n&quot;Fe K&quot;,e),[10.0e3,20.0e3])...)
0.5982578301818324</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.rename-Tuple{Material, AbstractString}" href="#NeXLCore.rename-Tuple{Material, AbstractString}"><code>NeXLCore.rename</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rename(mat::Material, newname::AbstractString)</code></pre><p>Creates a replica of <code>mat</code> but with a new name.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.requiredbutmissing-Tuple{Type, Dict{Symbol, Any}}" href="#NeXLCore.requiredbutmissing-Tuple{Type, Dict{Symbol, Any}}"><code>NeXLCore.requiredbutmissing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">requiredbutmissing(ty::Type, item::Union{Spectrum,Dict{Symbol,Any}})</code></pre><p>List any required but missing properties.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.resetmac!-Tuple{Element, CharXRay}" href="#NeXLCore.resetmac!-Tuple{Element, CharXRay}"><code>NeXLCore.resetmac!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ressetmac!(elm::Element, cxr::CharXRay)</code></pre><p>Restore the default mass absorption coefficient for the specified element and characteristic X-ray.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.sample-Tuple{Region}" href="#NeXLCore.sample-Tuple{Region}"><code>NeXLCore.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample(ch::Region)</code></pre><p>Extracts the sample portion from within the chamber.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.setmac!-Tuple{Element, CharXRay, Float64}" href="#NeXLCore.setmac!-Tuple{Element, CharXRay, Float64}"><code>NeXLCore.setmac!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setmac!(elm::Element, cxr::CharXRay, mac::Float64)</code></pre><p>Specify a custom mass absorption coefficient (MAC) for the specified X-ray in the specified element.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.shell-Tuple{AtomicSubShell}" href="#NeXLCore.shell-Tuple{AtomicSubShell}"><code>NeXLCore.shell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shell(ass::AtomicSubShell)</code></pre><p>Example:</p><pre><code class="nohighlight hljs">julia&gt; shell(n&quot;Fe L3&quot;)
Shell(L)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.shell-Tuple{CharXRay}" href="#NeXLCore.shell-Tuple{CharXRay}"><code>NeXLCore.shell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shell(cxr::CharXRay)</code></pre><p>Return the shell, Shell(1), Shell(2), ... associated with the inner shell.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.shell-Tuple{SubShell}" href="#NeXLCore.shell-Tuple{SubShell}"><code>NeXLCore.shell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shell(sh::SubShell)</code></pre><p>Returns the appropriate Shell object.</p><p>Example:</p><pre><code class="nohighlight hljs">julia&gt; shell(n&quot;M5&quot;)
Shell[M]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.shell-Tuple{Transition}" href="#NeXLCore.shell-Tuple{Transition}"><code>NeXLCore.shell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shell(tr::Transition)</code></pre><p>Return the shell (Shell(1), Shell(2),...) associated with the transition&#39;s inner shell.</p><p>Example:</p><pre><code class="nohighlight hljs">@assert shell(n&quot;K-L3&quot;)==Shell(1)
@assert shell(n&quot;M5-N7&quot;)==Shell(3)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.splitbyshell-Tuple{Any}" href="#NeXLCore.splitbyshell-Tuple{Any}"><code>NeXLCore.splitbyshell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">splitbyshell(cxrs)</code></pre><p>Splits a collection of CharXRay into a dictionary where the key is the inner AtomicSubShell and the values are a vector of CharXRay for that inner shell.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.stage2image-Tuple{Type{DefaultStageMapping}, Dict, Dict, Float64}" href="#NeXLCore.stage2image-Tuple{Type{DefaultStageMapping}, Dict, Dict, Float64}"><code>NeXLCore.stage2image</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stage2image(::Type{DefaultStageMapping}, stage_coord::Dict{Symbol,Any}, centered_coord::Dict{Symbol,Any}, theta::Float64)</code></pre><p><code>stage2image(...)</code> is the inverse function of <code>image2stage(...)</code>.  Given the stage coordinate of the center of the image  <code>stage_coord</code> and the stage coordinate that would center the pixel of interest <code>centered_coord</code>, compute the pixel coordinate corresponding to the <code>centered_coordinate</code> when the stage is at <code>stage_coord</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.standardize-Tuple{KRatio, KRatio}" href="#NeXLCore.standardize-Tuple{KRatio, KRatio}"><code>NeXLCore.standardize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">standardize(kr::KRatio, std::KRatio)::KRatio
standardize(kr::KRatios, std::KRatio)::KRatios
standardize(kratios::Union{AbstractVector{KRatio},AbstractVector{&lt;:KRatios}}, stds::AbstractVector{KRatio})</code></pre><p>If the <code>std::KRatio</code> is a suitable match for <code>kr</code> then <code>kr</code> is restandardized using <code>std</code>.  Otherwise, the original <code>KRatio</code> or <code>KRatios</code> is returned.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.subshell-Tuple{AbstractString}" href="#NeXLCore.subshell-Tuple{AbstractString}"><code>NeXLCore.subshell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subshell(name::AbstractString)::SubShell</code></pre><p>Returns a SubShell structure from a string of the form &quot;K&quot;, &quot;L1&quot;, ...., &quot;O11&quot;</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.symbol-Tuple{Element}" href="#NeXLCore.symbol-Tuple{Element}"><code>NeXLCore.symbol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symbol(elm::Element)</code></pre><p>Return the symbol like &quot;H&quot;, &quot;He&quot;, &quot;Li&quot;, .... for the Element.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.take_step-Union{Tuple{T}, Tuple{T, Region, Vararg{Float64, 4}}, Tuple{T, Region, Vararg{Float64, 5}}} where T&lt;:Particle" href="#NeXLCore.take_step-Union{Tuple{T}, Tuple{T, Region, Vararg{Float64, 4}}, Tuple{T, Region, Vararg{Float64, 5}}} where T&lt;:Particle"><code>NeXLCore.take_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">take_step(p::T, reg::Region, 𝜆::Float64, 𝜃::Float64, 𝜑::Float64)::Tuple{T, Region, Bool} where { T&lt;: Particle}</code></pre><p>Returns a <code>Tuple</code> containing a new <code>Particle</code> and the child-most <code>Region</code> in which the new <code>Particle</code> is found based on a scatter event consisting a translation of up to <code>𝜆</code> mean-free path along a new direction given relative to the current direction of <code>p</code> via the scatter angles <code>𝜃</code> and <code>𝜑</code>.</p><p>Returns the updated <code>Particle</code> reflecting the last trajectory step and the Region for the next step.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.thin_film-Tuple{Vararg{Pair{Material, Float64}}}" href="#NeXLCore.thin_film-Tuple{Vararg{Pair{Material, Float64}}}"><code>NeXLCore.thin_film</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">thin_film(prs::Pair{Material, Float64}...; substrate::Union{Nothing,Material} = nothing)</code></pre><p>Construct sample consisting of one or more thin films on an optional bulk substrate.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.trajectory-Union{Tuple{T}, Tuple{Function, T, Region, Function, Function}} where T&lt;:Particle" href="#NeXLCore.trajectory-Union{Tuple{T}, Tuple{Function, T, Region, Function, Function}} where T&lt;:Particle"><code>NeXLCore.trajectory</code></a> — <span class="docstring-category">Method</span></header><section><div><p>trajectory(eval::Function, p::T, reg::Region, scf::Function=transport; minE::Float64=50.0) where {T &lt;: Particle} trajectory(eval::Function, p::T, reg::Region, scf::Function, terminate::Function) where { T &lt;: Particle }</p><p>Run a single particle trajectory from <code>p</code> to <code>minE</code> or until the particle exits <code>reg</code>.</p><ul><li><code>eval(part::T, region::Region)</code> a function evaluated at each scattering point</li><li><code>p</code> defines the initial position, direction and energy of the particle (often created with <code>gun(T, ...)</code>)</li><li><code>reg</code> The outer-most region for the trajectory (usually created with <code>chamber()</code>)</li><li><code>scf</code> A function from (&lt;:Particle, Material) -&gt; ( λ, θ, ϕ, ΔE ) that implements the transport dynamics</li><li><code>minE</code> Stopping criterion</li><li><code>terminate</code> a function taking <code>T</code> and <code>Region</code> that returns false except on the last step (like <code>terminate = (pc,r)-&gt;pc.energy &lt; 50.0</code>)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.transition-Tuple{CharXRay}" href="#NeXLCore.transition-Tuple{CharXRay}"><code>NeXLCore.transition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transition(cxr::CharXRay)</code></pre><p>Return the Transition structure associated with the specified CharXRay.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.transition-Tuple{SubShell, SubShell}" href="#NeXLCore.transition-Tuple{SubShell, SubShell}"><code>NeXLCore.transition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transition(inner::SubShell, outer::SubShell)::Transition</code></pre><p>Return a Transition structure from an inner and outer shell. This function tests to ensure that the Transition is a known transition.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.transmission" href="#NeXLCore.transmission"><code>NeXLCore.transmission</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transmission(flm::Film, xrayE::AbstractFloat, θ::AbstractFloat = π/2, alg::Type{&lt;:NeXLAlgorithm} = DefaultAlgorithm)
transmission(flm::Film, cxr::CharXRay, θ::AbstractFloat = π/2, alg::Type{&lt;:NeXLAlgorithm} = DefaultAlgorithm)</code></pre><p>Compute the transmission fraction of an X-ray at the specified angle through a Film.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.transport" href="#NeXLCore.transport"><code>NeXLCore.transport</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transport(pc::Electron, mat::Material, ecx=Liljequist1989, bethe=JoyLuo)::NTuple{4, Float64}</code></pre><p>The default function defining elastic scattering and energy loss for an Electron.</p><p>Returns ( <code>λ</code>, <code>θ</code>, <code>ϕ</code>, <code>ΔE</code>) where <code>λ</code> is the mean path length, <code>θ</code> is the elastic scatter angle, <code>ϕ</code> is the azimuthal elastic scatter angle and <code>ΔE</code> is the energy loss for transport over the distance <code>λ</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.vₑ-Tuple{Unitful.Quantity}" href="#NeXLCore.vₑ-Tuple{Unitful.Quantity}"><code>NeXLCore.vₑ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Electron velocity in cm/s for the specified kinetic energy in eV.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.wavenumber-Tuple{CharXRay}" href="#NeXLCore.wavenumber-Tuple{CharXRay}"><code>NeXLCore.wavenumber</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wavenumber(cxr::CharXRay)</code></pre><p>X-ray wavenumber in cm¯¹.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.weight-Tuple{Type{&lt;:NeXLCore.WeightNormalization}, CharXRay}" href="#NeXLCore.weight-Tuple{Type{&lt;:NeXLCore.WeightNormalization}, CharXRay}"><code>NeXLCore.weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">weight(::Type{&lt;:WeightNormalization}, cxr::CharXRay)</code></pre><p>where <code>WeightNormalization</code> is one of the following:</p><ul><li><code>NormalizeByShell</code> normalizes the sum of all the weights associated with a shell to unity.</li><li><code>NormalizeBySubShell</code> normalizes the sum of all the weights associated with each sub-shell to unity.</li><li><code>NormalizeToUnity</code> normalizes intensities such that the most intense line in each shell to 1.0.</li></ul><p>Computes a rough estimate of the relative intensity of <code>cxr</code> relative to the other characteristic X-rays in its shell, sub-shell etc. The different <code>WeightNormalization</code> modes reflect different ways that the <code>weight(...)</code> function is used.</p><p>The difference between <code>fluorescenceyield(...)</code> and <code>weight(...)</code> is that</p><ul><li>fluorescenceyield assumes that a sub-shell in the atom is already ionized</li><li>weight also considers the relative likelihood of ionization of each sub-shell assuming an overvoltage of 4.0.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.wikidata_minerals-Tuple{}" href="#NeXLCore.wikidata_minerals-Tuple{}"><code>NeXLCore.wikidata_minerals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wikidata_minerals()::Dict{String, Material}</code></pre><p>Mineral data based on a WikiData SPARQL query of minerals. Only those minerals which represented distinct (uniquely defined) compositions are included.  Replicas were removed.</p><p>Also includes <code>:Class</code>, <code>:Formula</code> and <code>:Description</code> properties.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.z-Tuple{Element}" href="#NeXLCore.z-Tuple{Element}"><code>NeXLCore.z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">z(elm::Element)</code></pre><p>Return the atomic number of the Element.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.z-Tuple{Material}" href="#NeXLCore.z-Tuple{Material}"><code>NeXLCore.z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">z(mat::Material) = z(Donovan2002, mat)
z(::Type{NaiveZ|ElectronFraction|AtomicFraction}, mat::Material)
z(::Type{ElasticFraction}, mat::Material, e::AbstractFloat)
z(::Type{Donovan2002}, mat::Material; exponent=0.667)</code></pre><p>Compute the mean atomic number for a material.</p><pre><code class="nohighlight hljs">Algorithms:
  * NaiveZ - Mass fraction averaging
  * AtomFraction - Atom fraction averaging
  * ElectronFraction - Simple electron fraction averaging
  * ElasticFraction - Scattering cross-section averaged
  * Donovan2002 - Yukawa/Donovan modified exponent electron fraction averaging</code></pre><p>For more details see Mean Z algorithm in J.J. Donovan, N.E. Pingitore, Microsc. Microanal. 2002 ; 8 , 429 (also see Microsc. Microanal. 27 (Suppl 1), 2021))</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.zbar-Tuple{Material}" href="#NeXLCore.zbar-Tuple{Material}"><code>NeXLCore.zbar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zbar(mat::Material)::Float64</code></pre><p>The mean atomic number as calculated using</p><p>@article{donovan2003compositional,   title={Compositional averaging of backscatter intensities in compounds},   author={Donovan, John J and Pingitore, Nicholas E and Westphal, Andrew},   journal={Microscopy and Microanalysis},   volume={9},   number={3},   pages={202–215},   year={2003},   publisher={Cambridge University Press} }</p><p>or, equivalently,</p><p>@article{saldick1954backscattering,   title={Backscattering from Targets of Low Atomic Number Bombarded with 1—2 Mev Electrons},   author={Saldick, Jerome and Allen, Augustine O},   journal={The Journal of Chemical Physics},   volume={22},   number={10},   pages={1777–1777},   year={1954},   publisher={American Institute of Physics} }</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.γₑ-Tuple{Unitful.Quantity}" href="#NeXLCore.γₑ-Tuple{Unitful.Quantity}"><code>NeXLCore.γₑ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Relativistic γ for v in cm/s</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.δσδΩ-Tuple{Type{ScreenedRutherford}, Float64, Element, Float64}" href="#NeXLCore.δσδΩ-Tuple{Type{ScreenedRutherford}, Float64, Element, Float64}"><code>NeXLCore.δσδΩ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">δσδΩ(::Type{ScreenedRutherford}, θ::Float64, elm::Element, E::Float64)::Float64</code></pre><p>The <em>differential</em> screened Rutherford cross-section per atom. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.η-Tuple{Element, Real}" href="#NeXLCore.η-Tuple{Element, Real}"><code>NeXLCore.η</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">η(::Type{&lt;:BackscatterCoefficient}, mat::Material, e0::Float64) = #
η(elm::Element, e0::Real)</code></pre><p>Models are: Tomlin1963, LoveScott1978η, Pouchou1991η, August1989η, Reimer1998</p><p>The default backscatter coefficient algorith is August1989η.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.η-Tuple{Type{&lt;:NeXLCore.BackscatterCoefficient}, Material, Float64}" href="#NeXLCore.η-Tuple{Type{&lt;:NeXLCore.BackscatterCoefficient}, Material, Float64}"><code>NeXLCore.η</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">η([ty::Type{&lt;:BackscatterCoefficient},] mat::Material, e0::Float64)::Float64 =</code></pre><p>Calculate the backscatter coefficient for a material using Armstrong&#39;s 1991 algorithm for materials.</p><p>@incollection{armstrong1991quantitative,   title={Quantitative elemental analysis of individual microparticles with electron beam instruments},   author={Armstrong, John T},   booktitle={Electron probe quantitation},   pages={261–315},   year={1991},   publisher={Springer} }</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.λ-Tuple{CharXRay}" href="#NeXLCore.λ-Tuple{CharXRay}"><code>NeXLCore.λ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">λ(cxr::CharXRay)</code></pre><p>X-ray wavelength in cm.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.λ-Tuple{Type{&lt;:ScreenedRutherfordType}, Element, Float64, Float64}" href="#NeXLCore.λ-Tuple{Type{&lt;:ScreenedRutherfordType}, Element, Float64, Float64}"><code>NeXLCore.λ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">λ(ty::Type{&lt;:ElasticScatteringCrossSection}, θ::Float64, elm::Element, E::Float64)::Float64</code></pre><p>The mean free path.  The mean distance between elastic scattering events. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.λₑ-Tuple{Unitful.Quantity}" href="#NeXLCore.λₑ-Tuple{Unitful.Quantity}"><code>NeXLCore.λₑ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">λₑ(E::Float64)</code></pre><p>Wavelength of an electron in cm.</p><ul><li>E in eV</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.λₜᵣ-Tuple{Type{&lt;:ElasticScatteringCrossSection}, Element, Float64, Float64}" href="#NeXLCore.λₜᵣ-Tuple{Type{&lt;:ElasticScatteringCrossSection}, Element, Float64, Float64}"><code>NeXLCore.λₜᵣ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">λₜᵣ(ty::Type{&lt;:ElasticScatteringCrossSection}, θ::Float64, elm::Element, E::Float64)::Float64
λₜᵣ(ty::Type{&lt;:ScreenedRutherfordType}, mat::Material, elm::Element, E::Float64)</code></pre><p>The transport mean free path. The mean distance in the initial direction of propagation between elastic scattering events.</p><ul><li>N is the number of atoms per cm³</li><li>E is the electron kinetic energy in eV </li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.ξ-Tuple{Type{&lt;:ScreenedRutherfordType}, Element, Float64}" href="#NeXLCore.ξ-Tuple{Type{&lt;:ScreenedRutherfordType}, Element, Float64}"><code>NeXLCore.ξ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ξ(::Type{&lt;:ScreenedRutherfordType}, elm::Element, E::Float64)::Float64</code></pre><ul><li>E in eV</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.σₜ-Tuple{Type{ScreenedRutherford}, Element, Float64}" href="#NeXLCore.σₜ-Tuple{Type{ScreenedRutherford}, Element, Float64}"><code>NeXLCore.σₜ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">σₜ(::Type{ScreenedRutherford}, elm::Element, E::Float64)
σₜ(::Type{Liljequest1989}, elm::Element, E::Float64)
σₜ(::Type{Browning1991}, elm::Element, E::Float64)
σₜ(::Type{Browning1994}, elm::Element, E::Float64)</code></pre><p>Total cross section per atom in cm².</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.σₜᵣ-Tuple{Type{ScreenedRutherford}, Element, Float64}" href="#NeXLCore.σₜᵣ-Tuple{Type{ScreenedRutherford}, Element, Float64}"><code>NeXLCore.σₜᵣ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">σₜᵣ(::Type{ScreenedRutherford}, elm::Element, E::Float64)</code></pre><p>The transport cross-section in cm².  The transport cross-section gives the correct transport mean free path - the mean free path in the direction of initial propagation after an infinite number of collisions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.ϵ-Tuple{Type{&lt;:ScreenedRutherfordType}, Element, Float64}" href="#NeXLCore.ϵ-Tuple{Type{&lt;:ScreenedRutherfordType}, Element, Float64}"><code>NeXLCore.ϵ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ϵ(elm::Element, E::Float64)</code></pre><p>Screening factor.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLUncertainties.asa" href="#NeXLUncertainties.asa"><code>NeXLUncertainties.asa</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">NeXLUncertainties.asa(::Type{DataFrame}, mats::AbstractArray{Material}, mode=:MassFraction)</code></pre><p>Tabulate the composition of a list of materials in a DataFrame.  One column for each element in any of the materials.</p><pre><code class="nohighlight hljs">mode = :MassFraction | :NormalizedMassFraction | :AtomicFraction.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLUncertainties.asa-Tuple{Type{DataFrames.DataFrame}, Dict{Element, String}}" href="#NeXLUncertainties.asa-Tuple{Type{DataFrames.DataFrame}, Dict{Element, String}}"><code>NeXLUncertainties.asa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">asa(::Type{DataFrame}, links::Dict{Element,String})</code></pre><p>Create a DataFrame which contains a periodic table with links to URLs. This doesn&#39;t work so well at the REPL when represented as text but works nicely in HTML.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLUncertainties.asa-Tuple{Type{DataFrames.DataFrame}, Material}" href="#NeXLUncertainties.asa-Tuple{Type{DataFrames.DataFrame}, Material}"><code>NeXLUncertainties.asa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NeXLUncertainties.asa(::Type{DataFrame}, mat::Material)</code></pre><p>Tabulate the composition of this Material as a DataFrame.  Columns for material name, element abbreviation, atomic number, atomic weight, mass fraction, normalized mass fraction, and atomic fraction. Rows for each element in mat.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLUncertainties.asa-Tuple{Type{Dict}, Material}" href="#NeXLUncertainties.asa-Tuple{Type{Dict}, Material}"><code>NeXLUncertainties.asa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NeXLUncertainties.asa(Dict, mat::Material)</code></pre><p>Convert a <code>Material</code> into a <code>Dict{String, Any}</code> as is suitable for conversion to JSON.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLUncertainties.asa-Tuple{Type{LaTeXStrings.LaTeXString}, Material}" href="#NeXLUncertainties.asa-Tuple{Type{LaTeXStrings.LaTeXString}, Material}"><code>NeXLUncertainties.asa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NeXLUncertainties.asa(::Type{LaTeXString}, mat::Material; parsename=true, order = :massfraction | :z)</code></pre><p>Converts a <code>Material</code> into a <code>LaTeXString</code>.  <code>parsename</code> controls whether the material name is assumed to be a parsable chemical formula (according to \ce{...}).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.mean-Tuple{AbstractArray{&lt;:Material}}" href="#Statistics.mean-Tuple{AbstractArray{&lt;:Material}}"><code>Statistics.mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Statistics.mean(mats::AbstractArray{&lt;:Material})</code></pre><p>If the mass fractions for all the elements in all <code>mats</code> have non-zero uncertainties then the variance weighted mean is calculated and the result will have associated  uncertainties.  Otherwise, the straight floating-point mean is calculated and the result won&#39;t have uncertainties.  This is because even a single value with zero uncertainty will poison the variance weighted mean (produce a NaN).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.@n_str-Tuple{Any}" href="#NeXLCore.@n_str-Tuple{Any}"><code>NeXLCore.@n_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">n&quot;Fe&quot;</code></pre><p>Implements compile time parsing of strings to produce Element, SubShell, AtomicSubShell, Transition or CharXRay objects.  The only oddity is that to get SubShell(&quot;K&quot;) you must enter n&quot;K1&quot; to differentiate the sub-shell from potassium. Examples:</p><pre><code class="nohighlight hljs">n&quot;Fe&quot; == elements[26]
n&quot;K&quot; == elements[19]
n&quot;K1&quot; == subshell(&quot;K&quot;)
n&quot;L3&quot; == subshell(&quot;L3&quot;)
n&quot;Fe L3&quot; == AtomicSubShell(elements[26],subshell(&quot;L3&quot;))
n&quot;L3-M5&quot; == Transition(SubShell(&quot;L3&quot;),&quot;SubShell(&quot;M5&quot;))
n&quot;Fe L3-M5&quot; == CharXRay(elements[26],Transition(SubShell(&quot;L3&quot;),&quot;SubShell(&quot;M5&quot;))</code></pre></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../meanionizationpotential/">« Mean Ionization Potential</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 26 June 2023 15:07">Monday 26 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
